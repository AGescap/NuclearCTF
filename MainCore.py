import numpy as np
import sys
import math

'''
This Python script is aimed at processing an input file of CTF core simulation code, which has been generated by CTF preprocessor [1]. 
The input of this script will be a Core input file -i.e. more than one Fuel Assembly- The output of this file will be a  new CTF input file where previous subchannels
have been merged into larger ones. This code is not much pythonic, but that makes it easier to be read by a Matlab user. Many of the instructions assume
that there are no empty lines in the begginning of a Card, whereas most of them are ok with blank lines at the end of a Card.


 
Author: Álvaro González Escapa
Institution: Polytechnic University of Madrid
Python version: 3.8 


References:
[1]. Avramova, Maria N. and Salko, Robert (2016). CTF preprocessor's user manual. Pennsylvania State University. Reactor dynamics and fuel management group

'''


def findcardinline(doc, string, time=1):
    # so as to count the iterations. Caution is needed with the string here, because if one types
    # e.g. Card 3.3., it will find both Card 3.3 or Card 3.3.5.
    # With the variable time, it can now look for the n-th time that the Card appears (like in axial or radial profiles)
    cont = 0
    locus = -1
    clock = 1
    for linex in doc:

        # find returns the first position of the sequence that appears in the line. Should it not appear,
        # find returns -1. The exact value does not matter, only its presence

        if linex.find(string) >= 0:
            if clock < time:
                clock = clock + 1
                cont = cont + 1
            else:
                locus = cont
                break
        else:
            cont = cont + 1
    return locus


def findheaderinline(doc, string, time=1, separator=" "):
    cont = 0
    locus = -1
    clock = 1
    for linex in doc:
        if linex.replace(separator, "").find(string.replace(separator, "")) >= 0:
            if clock < time:
                clock = clock+1
                cont = cont + 1
            else:
                locus = cont
                break
        else:
            cont = cont + 1
    return locus


def findnextto(doc, string1, string2, time1=1, time2=1):
    start = int(findheaderinline(doc, string1, time=time1))
    aux_doc = [None]*(len(doc) - start)
    for i in range(0, len(doc) - start):
        aux_doc[i] = doc[i+start]

    finish = findheaderinline(aux_doc, string2, time=time2) + start
    return finish


# removeexcesslines takes a list of strings (the result of readlines method), sets an origin
# (ideally, a variables header) and from that, counts PRIOR lines -like the ones in Group 4 of deck.inp in CTF-
# in the new situation, ACTUAL lines must be conserved, from the position BEGIN, and thus REMOVE lines must be erased


def removeexcesslines(doc, begin, prior, actual):
    remove = prior - actual
    for i in range(0, remove):
        doc.pop(begin+actual+1)


def rewritesomelines(doc, begin, piece):
    # rewrites all the lines in piece. First one replaced is the next one to "begin"
    for i in range(0, len(piece)):
        doc[begin+1+i] = piece[i] + " \n"


# deletebetweencards looks for the position number time 1 of the Card 1 and deletes everything
# (including Card1) until it finds Card 2 (for the time2-th occasion)
def deletebetweencards(doc, card1, card2, time1=1, time2=1):
    pos1 = findcardinline(doc, card1, time1)
    pos2 = findcardinline(doc, card2, time2)
    for i in range(0, pos2 - pos1):
        doc.pop(pos1)


def chanindex_xy(x, y, numchannelside):
    # chanindex: from the x, y position (origin in bottom left corner), gets the index of the channel.
    # Numeration begins at top left and goes first rightwards and then downwards.
    # System of reference: x increases to the right, y increases from the bottom to the top
    return x+(numchannelside - y)*numchannelside


def retrieve_xy(index, numchannelside):
    # retrieve_xy: from the index and the number of channels per side, gets x and y (origin in bottom left corner). This
    # does not apply exclusively for subchannel, but for any homogenization
    y = numchannelside - (index - 1) // numchannelside
    x = index - (numchannelside - y)*numchannelside
    return [x, y]


def refchannel(numchannel, dlevel, n_sbchn_side):
    # f rom the number of a newly created channel (1,2,...N/Dlev**2), gets global index of its top left channel
    new_chn_per_side = n_sbchn_side / dlevel
    [x, y] = retrieve_xy(numchannel, new_chn_per_side)
    return 1 + (x-1) * dlevel + (new_chn_per_side - y) * n_sbchn_side * dlevel


def format_e(n):    # This function allows to write a float as a string with scientific notation
    a = '%E' % n
    return a.split('E')[0].rstrip('0').rstrip('.') + 'E' + a.split('E')[1]


def ret_FA(numcols, numfa):
    '''
    This function returns the position
    '''
    a = [int((numfa - 1) // numcols + 1), int(numfa - numcols*(((numfa - 1) // numcols + 1)-1))]
    return a

def main():
    '''
    Here the approach is that of deducting all the subchannel properties from prepro data, given that some features as
    the guide tubes location are more explicitly given in those files, rather than in deck.inp (the coordinates appear,
    whereas in deck.inp a search should be done in the radial power profile)
    '''
    # open the deck file and also the prepro files
    file = open("deck.inp", "r")
    lines = file.readlines()
    file.close()

    file_control = open("control.inp", "r")
    l_control = file_control.readlines()
    file_control.close()

    file_geo = open("geo.inp", "r")
    l_geo = file_geo.readlines()
    file_geo.close()

    file_assem = open("assem.inp", "r")
    l_assem = file_assem.readlines()
    file_assem.close()

    file_power = open("power.inp", "r")
    l_power = file_power.readlines()
    file_power.close()

    '''
    Begin the READS and simple Calculations, not DELETES nor WRITES yet
    '''

    # gets number of fuel assemblies in assem.inp
    fa_num = int(l_geo[findheaderinline(l_geo, "*Number of fuel assemblies")+1].split()[0])
    fa_types = int(l_geo[findheaderinline(l_geo, "NUMBER OF FUEL ASSEMBLY TYPES") + 1].split()[0])
    fa_numcol = int(l_geo[findheaderinline(l_geo, "CORE MESH X Y")+1].split()[0])
    fa_numrow = int(l_geo[findheaderinline(l_geo, "CORE MESH X Y")+1].split()[1])

    # gets rods number in the assembly

    nfrods = int(l_assem[findheaderinline(l_assem, "Number of fuel rods")+1].split()[0])

    # gets number of guidetubes

    ngt = int(l_assem[findheaderinline(l_assem, "Number of guide tubes/water rods") + 1].split()[0])

    # total number of rods, rods per side, channels per side, discretization level

    nrods = nfrods + ngt
    nrods_side = int(np.sqrt(nrods))
    nchn_side = nrods_side + 1
    nchn = nchn_side**2
    dlev = 2

    if nchn_side % dlev != 0:
        print("ERROR: The original number of channels per side is not divisible by dlev: " + str(dlev) + "\n")
        sys.exit(1)

    # new number of channels in the new, homogenized bundle

    newchn = int(nchn/(dlev**2))
    newchn_side = int(nchn_side/dlev)
    newchn_tot = fa_num*newchn

    # gets bundle pitch and converts it into m

    bp = np.float64(l_assem[findheaderinline(l_assem, "Bundle pitch") + 1].split()[0])
    bp = bp / 1000

    # gets pin pitch and converts it into mm

    pp = float(l_assem[findheaderinline(l_assem, "Pin pitch") + 1].split()[0])
    pp = pp / 1000

    # gets position of guide tubes if there are any. with the origin in top left corner of the FA,
    # the "0th" position marks the row and "1st" position, the column

    fr_od = float(l_assem[findheaderinline(l_assem, "Cladding outer diameter") + 1].split()[0])
    fr_od = fr_od/1000

    gtpos = np.zeros((ngt, 2), dtype=int)
    rodtype = np.zeros(nrods, dtype=int)
    auxvar = []

    if ngt > 0:

        for i in range(ngt):
            linaux = l_assem[findheaderinline(l_assem, "Use X Y format") + 1+i].split()
            gtpos[i][0] = int(linaux[0])
            gtpos[i][1] = int(linaux[1])
            auxvar = nrods_side*(gtpos[i][0]-1) + gtpos[i][1] - 1
            rodtype[auxvar] = 1

        gt_od = float(l_assem[findheaderinline(l_assem, "Outer diameter of guide tube/water rod") + 1].split()[0])
        gt_od = gt_od/1000

    # stores the fuel assembly map

    core_map = np.zeros((fa_numrow, fa_numcol), dtype=int)
    for i in range(fa_numrow):
        linaux = (l_geo[findheaderinline(l_geo, "FUEL ASSEMBLY MAP") + 2+i].split())
        for j in range(fa_numcol):
            core_map[i][j] = float(linaux[j+1])

    # creates absolute coordinates for the center of the different FAs. They are created for both empty-water-
    # FAs so that it has to be filtered afterwards. The reference is set in top left corner so that
    # first coordinate refers to rows and second coordinate refers to columns

    core_cent = np.zeros((fa_numrow, fa_numcol, 2), dtype=float)

    for i in range(fa_numcol):
        for j in range(fa_numrow):
            core_cent[j][i][0] = ((i+1) - 0.5 - float(fa_numcol)/2)*bp
            core_cent[j][i][1] = (float(fa_numrow)/2 + 0.5 - (j+1))*bp


    # this matrix will only contain the center of the FAs

    fa_cent = np.zeros((fa_num, 2), dtype=float)

    # stores the fuel assembly map
    # fa_transl contains an ordered list of the positions in the core array that have an actual FA
    fa_transl = np.zeros(fa_num, dtype=int)
    fa_types = np.zeros(fa_num, dtype=int)

    # core map has the core map, with the positions and the indexes

    core_map = np.zeros((fa_numrow, fa_numcol), dtype=int)
    cont_a = 1
    cont_b = 0

    # edit fa_transl, edit core_map

    for i in range(fa_numrow):
        linaux = (l_geo[findheaderinline(l_geo, "FUEL ASSEMBLY MAP") + 2+i].split())
        for j in range(fa_numcol):
            if int(linaux[j+1]) != 0:
                fa_transl[cont_b] = cont_a
                fa_types[cont_b] = int(linaux[j+1])
                fa_cent[cont_b] = core_cent[i][j]
                cont_b = cont_b + 1

            core_map[i][j] = int(linaux[j+1])
            cont_a = cont_a + 1

    # conectivity of the different subchannels

    fa_connect = np.zeros((fa_num, 2), dtype=int)
    # a matrix that stores two values for every fuel assembly. First component is valued 1 if there is another
    # FA just rightwards and valued 0 if not. The same for the second component but it checks if there is a FA
    # just downwards

    for i in range(0, fa_num - 1):
        auxvar = ret_FA(fa_numcol, fa_transl[i])
        if fa_transl[i] > fa_numcol:
            if fa_transl[i] % fa_numcol != 0:
                if fa_transl[i] // fa_numcol != fa_numrow - 1:
                    if core_map[auxvar[0]-1][auxvar[1]] != 0:
                        fa_connect[i][0] = 1
                    if core_map[auxvar[0]][auxvar[1]-1] != 0:
                        fa_connect[i][1] = 1

                else:
                    if core_map[auxvar[0]-1][auxvar[1]] != 0:
                        fa_connect[i][0] = 1

            else:
                if core_map[auxvar[0]][auxvar[1] - 1] != 0:
                    fa_connect[i][1] = 1

        else:
            if fa_transl[i] % fa_numcol != 0:
                if core_map[auxvar[0] - 1][auxvar[1]] != 0:
                    fa_connect[i][0] = 1
                if core_map[auxvar[0]][auxvar[1] - 1] != 0:
                    fa_connect[i][1] = 1
            else:
                if core_map[auxvar[0]][auxvar[1] - 1] != 0:
                    fa_connect[i][1] = 1

    # local parameters in a FA
    free_sp = (bp - (nrods_side-1)*pp)/2

    # now, for every FA type, generic info about channels (An, Pw, XSIZ, YSIZ) should be created
    # gaps data demands more complexity

    # creates an array

    od_s = []

    if ngt > 0:
        od_s = np.ones(2, dtype=float)
        od_s[0] = fr_od
        od_s[1] = gt_od

    print(rodtype)
    od_rods = fr_od*np.ones(nrods, dtype=float)
    print(ngt)
    print(od_s)
    if ngt > 0:
        for i in range(0, nrods):
            od_rods[i] = od_s[rodtype[i]]

    # creates an array with the subchannels that correspond to a rod

    subchannels_in_rod = np.zeros((nrods, 2, 2), dtype=int)

    for i in range(0, nrods):
        top = i+1 + i//(nchn_side-1)
        subchannels_in_rod[i][0][0] = top
        subchannels_in_rod[i][0][1] = top + 1
        subchannels_in_rod[i][1][0] = top + nchn_side
        subchannels_in_rod[i][1][1] = top + nchn_side+1

    # creates a matrix to store the data of the subchannels, so they can be merged afterwards

    an = np.zeros(nchn, dtype=np.float64)
    pw = np.zeros(nchn, dtype=np.float64)
    xsiz = np.zeros(nchn, dtype=np.float64)
    ysiz = np.zeros(nchn, dtype=np.float64)
    coords = np.zeros(nchn_side, dtype=np.float64)
    channX = np.zeros(nchn, dtype=np.float64)
    channY = np.zeros(nchn, dtype=np.float64)

    # identifies corner, side (horizontal and vertical) and center subchannels

    chan_corner = np.array([1, nchn_side, nchn - nchn_side + 1, nchn], dtype=int)
    chan_sideH = np.zeros(2*(nchn_side-2), dtype=int)
    chan_sideV = np.zeros(2*(nchn_side-2), dtype=int)
    chan_center = np.zeros((nchn_side - 2)**2, dtype=int)

    for i in range(0, nchn_side-2):
        chan_sideH[i] = 2+i
        chan_sideH[nchn_side-2+i] = nchn - nchn_side + 2 + i
        chan_sideV[2*i] = nchn_side + 1 + i*nchn_side
        chan_sideV[2*i+1] = 2*nchn_side + i*nchn_side

    for i in range(0, (nchn_side-2)**2):
        chan_center[i] = nchn_side + 2 + i % (nchn_side-2) + nchn_side * (i // (nchn_side-2))

    #gives values to the subchannel data

    coords[0] = -bp/2 + free_sp/2
    coords[-1] = bp/2 - free_sp/2
    for i in range(1, nchn_side-1):
        coords[i] = -bp/2 + free_sp + pp / 2 + (i-1)*pp

    #edits coordinate data

    for i in range(0, nchn):
        channX[i] = coords[i % nchn_side]
        channY[i] = coords[-(i//nchn_side + 1)]

    for i in range(0, 4):
        xsiz[chan_corner[i]-1] = free_sp
        ysiz[chan_corner[i]-1] = free_sp

    for i in range(0, 2*(nchn_side-2)):
        xsiz[chan_sideH[i] - 1] = pp
        ysiz[chan_sideH[i] - 1] = free_sp
        xsiz[chan_sideV[i] - 1] = free_sp
        ysiz[chan_sideV[i] - 1] = pp

    for i in range(0, (nchn_side-2)**2):
        xsiz[chan_center[i] - 1] = pp
        ysiz[chan_center[i] - 1] = pp

    # edits nominal area and wet perimeter for the channels

    for i in range(0, nchn):
        an[i] = xsiz[i]*ysiz[i]

    for i in range(0, nrods):
        for j in range(0, 2):
            for k in range(0, 2):
                an[subchannels_in_rod[i][j][k]-1] -= math.pi/4 * (od_rods[i]**2) * 0.25
                pw[subchannels_in_rod[i][j][k]-1] += math.pi * od_rods[i] * 0.25


    # creates an array that stores the number of subchannels that belong to the new channel
    subchannels_in_channel = np.zeros((newchn, dlev, dlev), dtype=int)
    for i in range(0, newchn):
        for j in range(0, dlev):
            for k in range(0, dlev):
                subchannels_in_channel[i][j][k] = refchannel(i+1, dlev, nchn_side) + j*nchn_side + k

    # defines a function that finds if a subchannel (subch) is contained in a certain new channel that
    # will contain dlev*dlev subchannels

    def findsubchannelinchannel(sub2chan, subch):
        aux = 0
        for i in range(0, newchn):
            for j in range(0, dlev):
                for k in range(0, dlev):
                    if sub2chan[i][j][k] == subch:
                        aux = i + 1
                        break
        return aux

    # new channel data

    new_an_pw = np.zeros((newchn, 2))
    new_sizes = np.zeros((newchn, 2))
    new_loc_channels = np.zeros((newchn, 2))
    for i in range(0, subchannels_in_channel.shape[0]):
        aux1 = 0
        aux2 = 0
        aux_x = 0
        aux_y = 0
        for j in range(0, subchannels_in_channel.shape[1]):
            for k in range(0,  subchannels_in_channel.shape[2]):
                aux1 += an[int(subchannels_in_channel[i][j][k])-1]
                aux2 += pw[int(subchannels_in_channel[i][j][k])-1]
                if j == 0:
                    aux_x += xsiz[int(subchannels_in_channel[i][j][k])-1]
                if k == 0:
                    aux_y += ysiz[int(subchannels_in_channel[i][j][k])-1]

        new_an_pw[i][0] = aux1
        new_an_pw[i][1] = aux2
        new_sizes[i][0] = aux_x
        new_sizes[i][1] = aux_y
        if i == 0:
            new_loc_channels[0][0] = -bp/2 + new_sizes[0][0]/2
            new_loc_channels[0][1] = bp/2 - new_sizes[0][1]/2
        else:
            if ((i-1) // nchn_side) == (i // nchn_side):
                new_loc_channels[i][0] = new_loc_channels[i-1][0] + (new_sizes[i-1][0] + new_sizes[i][0])/2
                new_loc_channels[i][1] = new_loc_channels[i-1][1]
            else:
                new_loc_channels[i][0] = new_loc_channels[i-nchn_side][0]
                new_loc_channels[i][1] = new_loc_channels[i-nchn_side][1] - (new_sizes[i-nchn_side][1]+new_sizes[i][1])/2


    # creates data for the new channels
    channelsindextot = np.zeros(newchn_tot, dtype=int)
    for i in range(0, newchn_tot):
        channelsindextot[i] = (i+1)

    totchannelsxpos = np.zeros(newchn_tot, dtype=np.float64)
    totchannelsypos = np.zeros(newchn_tot, dtype=np.float64)

    assemb_in_row = np.zeros(fa_numrow, dtype=int)
    acum_assemb_in_row = np.zeros(fa_numrow, dtype=int)
    newchn_in_core_row = np.zeros(fa_numrow, dtype=int)
    acum_newchn_in_core_row = np.zeros(fa_numrow, dtype=int)
    newchn_in_fa_row = np.zeros(fa_numrow, dtype=int)
    acum_newchn_in_fa_row = np.zeros(fa_numrow, dtype=int)

    for i in range(0, fa_numrow):
        auxvar = 0
        for j in range(0, fa_numcol):
            if core_map[i][j] != 0:
                auxvar += 1

        assemb_in_row[i] = auxvar
        newchn_in_core_row[i] = auxvar * newchn_side
        newchn_in_fa_row[i] = auxvar * newchn

        if i == 0:

            acum_assemb_in_row[i] = assemb_in_row[i]
            acum_newchn_in_core_row[i] = newchn_in_core_row[i]
            acum_newchn_in_fa_row[i] = newchn_in_fa_row[i]

        else:
            acum_assemb_in_row[i] = acum_assemb_in_row[i-1] + assemb_in_row[i]
            acum_newchn_in_core_row[i] = acum_newchn_in_core_row[i-1] + newchn_in_core_row[i]
            acum_newchn_in_fa_row[i] = acum_newchn_in_fa_row[i-1] + newchn_in_fa_row[i]


    for i in range(0, newchn_tot):

        # TODO some lines should be added here so as to change the channel data depending on the type of the fa
        auxrow = 1
        for j in range(1, fa_numrow):
            if i+1 > acum_newchn_in_fa_row[j-1] and i+1 <=  acum_newchn_in_fa_row[j]:
                auxrow = j+1

        if auxrow == 0:
            chanreset = i + 1

        else:
            chanreset = i + 1 - acum_newchn_in_fa_row[auxrow-2]


        aux_fa = (i // newchn) + 1  # number of the FA #WRONG
        auxtype = fa_types[aux_fa - 1]





    print(fa_num)
    print(fa_types)
    print(fa_numcol)
    print(fa_numrow)
    print(nrods)
    print(nrods_side)
    print(nchn)
    print(nchn_side)
    print(newchn)
    print(pp)
    print(bp)
    print(core_map)

    if ngt > 0:
        print(gtpos)

    print(newchn_in_core_row)
    print(newchn_in_fa_row)
    print(acum_assemb_in_row)
    print(acum_newchn_in_fa_row)
    print(acum_newchn_in_core_row)
    print(core_map)
    print(fa_types)
    # Create the new file and write lines in it

    file = open('new_deck.inp', 'w')
    file.writelines(lines)
    file.close()

    # TODO Assess that it is compatible with different assembly types and power profiles
    # TODO correct the alignment when writing lines (e.g. in channels or gaps cards) -> deck.inp file is more readable


main()

