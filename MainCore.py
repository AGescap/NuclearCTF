import numpy as np
import sys
import math

'''
This Python script is aimed at processing an input file of CTF core simulation code, which has been generated by CTF preprocessor [1]. 
The input of this script will be a Core input file -i.e. more than one Fuel Assembly- The output of this file will be a  new CTF input file where previous subchannels
have been merged into larger ones. This code is not much pythonic, but that makes it easier to be read by a Matlab user. Many of the instructions assume
that there are no empty lines in the begginning of a Card, whereas most of them are ok with blank lines at the end of a Card.


 
Author: Álvaro González Escapa
Institution: Polytechnic University of Madrid
Python version: 3.8 


References:
[1]. Avramova, Maria N. and Salko, Robert (2016). CTF preprocessor's user manual. Pennsylvania State University. Reactor dynamics and fuel management group

'''


def findcardinline(doc, string, time=1):
    # so as to count the iterations. Caution is needed with the string here, because if one types
    # e.g. Card 3.3., it will find both Card 3.3 or Card 3.3.5.
    # With the variable time, it can now look for the n-th time that the Card appears (like in axial or radial profiles)
    cont = 0
    locus = -1
    clock = 1
    for linex in doc:

        # find returns the first position of the sequence that appears in the line. Should it not appear,
        # find returns -1. The exact value does not matter, only its presence

        if linex.find(string) >= 0:
            if clock < time:
                clock = clock + 1
                cont = cont + 1
            else:
                locus = cont
                break
        else:
            cont = cont + 1
    return locus


def findheaderinline(doc, string, time=1, separator=" "):
    cont = 0
    locus = -1
    clock = 1
    for linex in doc:
        if linex.replace(separator, "").find(string.replace(separator, "")) >= 0:
            if clock < time:
                clock = clock+1
                cont = cont + 1
            else:
                locus = cont
                break
        else:
            cont = cont + 1
    return locus


def findnextto(doc, string1, string2, time1=1, time2=1):
    start = int(findheaderinline(doc, string1, time=time1))
    aux_doc = [None]*(len(doc) - start)
    for i in range(0, len(doc) - start):
        aux_doc[i] = doc[i+start]

    finish = findheaderinline(aux_doc, string2, time=time2) + start
    return finish


# removeexcesslines takes a list of strings (the result of readlines method), sets an origin
# (ideally, a variables header) and from that, counts PRIOR lines -like the ones in Group 4 of deck.inp in CTF-
# in the new situation, ACTUAL lines must be conserved, from the position BEGIN, and thus REMOVE lines must be erased


def removeexcesslines(doc, begin, prior, actual):
    remove = prior - actual
    for i in range(0, remove):
        doc.pop(begin+actual+1)


def rewritesomelines(doc, begin, piece):
    # rewrites all the lines in piece. First one replaced is the next one to "begin"
    for i in range(0, len(piece)):
        doc[begin+1+i] = piece[i] + " \n"


# deletebetweencards looks for the position number time 1 of the Card 1 and deletes everything
# (including Card1) until it finds Card 2 (for the time2-th occasion)
def deletebetweencards(doc, card1, card2, time1=1, time2=1):
    pos1 = findcardinline(doc, card1, time1)
    pos2 = findcardinline(doc, card2, time2)
    for i in range(0, pos2 - pos1):
        doc.pop(pos1)


def chanindex_xy(x, y, numchannelside):
    # chanindex: from the x, y position (origin in bottom left corner), gets the index of the channel.
    # Numeration begins at top left and goes first rightwards and then downwards.
    # System of reference: x increases to the right, y increases from the bottom to the top
    return x+(numchannelside - y)*numchannelside


def retrieve_xy(index, numchannelside):
    # retrieve_xy: from the index and the number of channels per side, gets x and y (origin in bottom left corner). This
    # does not apply exclusively for subchannel, but for any homogenization
    y = numchannelside - (index - 1) // numchannelside
    x = index - (numchannelside - y)*numchannelside
    return [x, y]


def refchannel(numchannel, dlevel, n_sbchn_side):
    # f rom the number of a newly created channel (1,2,...N/Dlev**2), gets global index of its top left channel
    new_chn_per_side = n_sbchn_side / dlevel
    [x, y] = retrieve_xy(numchannel, new_chn_per_side)
    return 1 + (x-1) * dlevel + (new_chn_per_side - y) * n_sbchn_side * dlevel


def format_e(n):    # This function allows to write a float as a string with scientific notation
    a = '%E' % n
    return a.split('E')[0].rstrip('0').rstrip('.') + 'E' + a.split('E')[1]


def ret_FA(numcols, numfa):
    '''
    This function returns the position
    '''
    a = [int((numfa - 1) // numcols + 1), int(numfa - numcols*(((numfa - 1) // numcols + 1)-1))]
    return a

def main():
    '''
    Here the approach is that of deducting all the subchannel properties from prepro data, given that some features as
    the guide tubes location are more explicitly given in those files, rather than in deck.inp (the coordinates appear,
    whereas in deck.inp a search should be done in the radial power profile)
    '''
    # open the deck file and also the prepro files
    file = open("deck.inp", "r")
    lines = file.readlines()
    file.close()

    file_control = open("control.inp", "r")
    l_control = file_control.readlines()
    file_control.close()

    file_geo = open("geo.inp", "r")
    l_geo = file_geo.readlines()
    file_geo.close()

    file_assem = open("assem.inp", "r")
    l_assem = file_assem.readlines()
    file_assem.close()

    file_power = open("power.inp", "r")
    l_power = file_power.readlines()
    file_power.close()

    '''
    Begin the READS and simple Calculations, not DELETES nor WRITES yet
    '''

    # gets number of fuel assemblies in assem.inp
    fa_num = int(l_geo[findheaderinline(l_geo, "*Number of fuel assemblies")+1].split()[0])
    fa_types = int(l_geo[findheaderinline(l_geo, "NUMBER OF FUEL ASSEMBLY TYPES") + 1].split()[0])
    fa_numcol = int(l_geo[findheaderinline(l_geo, "CORE MESH X Y")+1].split()[0])
    fa_numrow = int(l_geo[findheaderinline(l_geo, "CORE MESH X Y")+1].split()[1])

    # gets rods number in the assembly

    nfrods = int(l_assem[findheaderinline(l_assem, "Number of fuel rods")+1].split()[0])

    # gets number of guidetubes

    ngt = int(l_assem[findheaderinline(l_assem, "Number of guide tubes/water rods") + 1].split()[0])

    # gets the old number of channels in the deck.inp

    nchn_tot = int(lines[findheaderinline(lines, "NCH NDM2 NDM3")+1].split()[0])

    # total number of rods, rods per side, channels per side, discretization level

    nrods = nfrods + ngt
    nrods_side = int(np.sqrt(nrods))
    nchn_side = nrods_side + 1
    nchn = nchn_side**2
    dlev = 2

    if nchn_side % dlev != 0:
        print("ERROR: The original number of channels per side is not divisible by dlev: " + str(dlev) + "\n")
        sys.exit(1)

    # new number of channels in the new, homogenized bundle

    newchn = int(nchn/(dlev**2))
    newchn_side = int(nchn_side/dlev)
    newchn_tot = fa_num*newchn
    newnrod_tot = newchn_tot

    # gets bundle pitch and converts it into m

    bp = np.float64(l_assem[findheaderinline(l_assem, "Bundle pitch") + 1].split()[0])
    bp = bp / 1000

    # gets pin pitch and converts it into mm

    pp = float(l_assem[findheaderinline(l_assem, "Pin pitch") + 1].split()[0])
    pp = pp / 1000

    # gets position of guide tubes if there are any. with the origin in top left corner of the FA,
    # the "0th" position marks the row and "1st" position, the column

    fr_od = float(l_assem[findheaderinline(l_assem, "Cladding outer diameter") + 1].split()[0])
    fr_od = fr_od/1000

    gtpos = np.zeros((ngt, 2), dtype=int)
    rodtype = np.zeros(nrods, dtype=int)
    auxvar = []

    if ngt > 0:

        for i in range(ngt):
            linaux = l_assem[findheaderinline(l_assem, "Use X Y format") + 1+i].split()
            gtpos[i][0] = int(linaux[0])
            gtpos[i][1] = int(linaux[1])
            auxvar = nrods_side*(gtpos[i][0]-1) + gtpos[i][1] - 1
            rodtype[auxvar] = 1

        gt_od = float(l_assem[findheaderinline(l_assem, "Outer diameter of guide tube/water rod") + 1].split()[0])
        gt_od = gt_od/1000

    # stores the fuel assembly map

    core_map = np.zeros((fa_numrow, fa_numcol), dtype=int)
    for i in range(fa_numrow):
        linaux = (l_geo[findheaderinline(l_geo, "FUEL ASSEMBLY MAP") + 2+i].split())
        for j in range(fa_numcol):
            core_map[i][j] = float(linaux[j+1])

    # creates absolute coordinates for the center of the different FAs. They are created for both empty-water-
    # FAs so that it has to be filtered afterwards. The reference is set in top left corner so that
    # first coordinate refers to rows and second coordinate refers to columns

    core_cent = np.zeros((fa_numrow, fa_numcol, 2), dtype=float)

    for i in range(fa_numcol):
        for j in range(fa_numrow):
            core_cent[j][i][0] = ((i+1) - 0.5 - float(fa_numcol)/2)*bp
            core_cent[j][i][1] = (float(fa_numrow)/2 + 0.5 - (j+1))*bp

    # this matrix will only contain the center of the FAs

    fa_cent = np.zeros((fa_num, 2), dtype=float)

    # stores the fuel assembly map
    # fa_transl contains an ordered list of the positions in the core array that have an actual FA
    fa_transl = np.zeros(fa_num, dtype=int)
    fa_types = np.zeros(fa_num, dtype=int)

    # core map has the core map, with the positions and the indexes

    core_map = np.zeros((fa_numrow, fa_numcol), dtype=int)
    cont_a = 1
    cont_b = 0

    # edit fa_transl, edit core_map

    for i in range(fa_numrow):
        linaux = (l_geo[findheaderinline(l_geo, "FUEL ASSEMBLY MAP") + 2+i].split())
        for j in range(fa_numcol):
            if int(linaux[j+1]) != 0:
                fa_transl[cont_b] = cont_a
                fa_types[cont_b] = int(linaux[j+1])
                fa_cent[cont_b] = core_cent[i][j]
                cont_b = cont_b + 1

            core_map[i][j] = int(linaux[j+1])
            cont_a = cont_a + 1

    # conectivity of the different subchannels

    fa_connect = np.zeros((fa_num, 2), dtype=int)
    num_sides_connect = int(0)
    # a matrix that stores two values for every fuel assembly. First component is valued 1 if there is another
    # FA just rightwards and valued 0 if not. The same for the second component but it checks if there is a FA
    # just downwards

    for i in range(0, fa_num - 1):
        auxvar = ret_FA(fa_numcol, fa_transl[i])
        if fa_transl[i] > fa_numcol:
            if fa_transl[i] % fa_numcol != 0:
                if fa_transl[i] // fa_numcol != fa_numrow - 1:
                    if core_map[auxvar[0]-1][auxvar[1]] != 0:
                        fa_connect[i][0] = 1
                    if core_map[auxvar[0]][auxvar[1]-1] != 0:
                        fa_connect[i][1] = 1

                else:
                    if core_map[auxvar[0]-1][auxvar[1]] != 0:
                        fa_connect[i][0] = 1

            else:
                if core_map[auxvar[0]][auxvar[1] - 1] != 0:
                    fa_connect[i][1] = 1

        else:
            if fa_transl[i] % fa_numcol != 0:
                if core_map[auxvar[0] - 1][auxvar[1]] != 0:
                    fa_connect[i][0] = 1
                if core_map[auxvar[0]][auxvar[1] - 1] != 0:
                    fa_connect[i][1] = 1
            else:
                if core_map[auxvar[0]][auxvar[1] - 1] != 0:
                    fa_connect[i][1] = 1

        num_sides_connect = num_sides_connect + fa_connect[i][0] + fa_connect[i][1]

    # local parameters in a FA
    free_sp = (bp - (nrods_side-1)*pp)/2

    # now, for every FA type, generic info about channels (An, Pw, XSIZ, YSIZ) should be created

    # creates an array to store the outer diameters of the rods

    od_s = []

    if ngt > 0:
        od_s = np.ones(2, dtype=float)
        od_s[0] = fr_od
        od_s[1] = gt_od

    # print(rodtype)
    od_rods = fr_od*np.ones(nrods, dtype=float)
    # print(ngt)
    # print(od_s)
    if ngt > 0:
        for i in range(0, nrods):
            od_rods[i] = od_s[rodtype[i]]

    # creates an array with the subchannels that correspond to a rod

    subchannels_in_rod = np.zeros((nrods, 2, 2), dtype=int)
    rods_for_subchannel = np.zeros((nchn, 2, 2), dtype=int)
    contvect = np.zeros(nchn, dtype=int)
    for i in range(0, nrods):
        top = i+1 + i//(nchn_side-1)
        subchannels_in_rod[i][0][0] = top
        subchannels_in_rod[i][0][1] = top + 1
        subchannels_in_rod[i][1][0] = top + nchn_side
        subchannels_in_rod[i][1][1] = top + nchn_side+1

    for i in range(0, nrods):
        for j in range(0, 2):
            for k in range(0, 2):
                rods_for_subchannel[subchannels_in_rod[i][j][k] - 1][1-j][1-k] = i + 1

    # creates a matrix to store the data of the subchannels, so they can be merged afterwards

    an = np.zeros(nchn, dtype=np.float64)
    pw = np.zeros(nchn, dtype=np.float64)
    xsiz = np.zeros(nchn, dtype=np.float64)
    ysiz = np.zeros(nchn, dtype=np.float64)
    coords = np.zeros(nchn_side, dtype=np.float64)
    channX = np.zeros(nchn, dtype=np.float64)
    channY = np.zeros(nchn, dtype=np.float64)

    # identifies corner, side (horizontal and vertical) and center subchannels

    chan_corner = np.array([1, nchn_side, nchn - nchn_side + 1, nchn], dtype=int)
    chan_sideH = np.zeros(2*(nchn_side-2), dtype=int)
    chan_sideV = np.zeros(2*(nchn_side-2), dtype=int)
    chan_center = np.zeros((nchn_side - 2)**2, dtype=int)

    for i in range(0, nchn_side-2):
        chan_sideH[i] = 2+i
        chan_sideH[nchn_side-2+i] = nchn - nchn_side + 2 + i
        chan_sideV[2*i] = nchn_side + 1 + i*nchn_side
        chan_sideV[2*i+1] = 2*nchn_side + i*nchn_side

    for i in range(0, (nchn_side-2)**2):
        chan_center[i] = nchn_side + 2 + i % (nchn_side-2) + nchn_side * (i // (nchn_side-2))

    # gives values to the subchannel data

    coords[0] = -bp/2 + free_sp/2
    coords[-1] = bp/2 - free_sp/2
    for i in range(1, nchn_side-1):
        coords[i] = -bp/2 + free_sp + pp / 2 + (i-1)*pp

    # edits coordinate data

    for i in range(0, nchn):
        channX[i] = coords[i % nchn_side]
        channY[i] = coords[-(i//nchn_side + 1)]

    for i in range(0, 4):
        xsiz[chan_corner[i]-1] = free_sp
        ysiz[chan_corner[i]-1] = free_sp

    for i in range(0, 2*(nchn_side-2)):
        xsiz[chan_sideH[i] - 1] = pp
        ysiz[chan_sideH[i] - 1] = free_sp
        xsiz[chan_sideV[i] - 1] = free_sp
        ysiz[chan_sideV[i] - 1] = pp

    for i in range(0, (nchn_side-2)**2):
        xsiz[chan_center[i] - 1] = pp
        ysiz[chan_center[i] - 1] = pp

    # edits nominal area and wet perimeter for the channels

    for i in range(0, nchn):
        an[i] = xsiz[i]*ysiz[i]

    for i in range(0, nrods):
        for j in range(0, 2):
            for k in range(0, 2):
                an[subchannels_in_rod[i][j][k]-1] -= math.pi/4 * (od_rods[i]**2) * 0.25
                pw[subchannels_in_rod[i][j][k]-1] += math.pi * od_rods[i] * 0.25

    # creates an array that stores the number of subchannels that belong to the new channel
    subchannels_in_channel = np.zeros((newchn, dlev, dlev), dtype=int)
    for i in range(0, newchn):
        for j in range(0, dlev):
            for k in range(0, dlev):
                subchannels_in_channel[i][j][k] = refchannel(i+1, dlev, nchn_side) + j*nchn_side + k

    # defines a function that finds if a subchannel (subch) is contained in a certain new channel that
    # will contain dlev*dlev subchannels

    def findsubchannelinchannel(sub2chan, subch):
        aux = 0
        for i in range(0, newchn):
            for j in range(0, dlev):
                for k in range(0, dlev):
                    if sub2chan[i][j][k] == subch:
                        aux = i + 1
                        break
        return aux

    # new channel data

    new_an_pw = np.zeros((newchn, 2))
    new_sizes = np.zeros((newchn, 2))
    new_loc_channels = np.zeros((newchn, 2))

    for i in range(0, subchannels_in_channel.shape[0]):
        aux1 = 0
        aux2 = 0
        aux_x = 0
        aux_y = 0
        for j in range(0, subchannels_in_channel.shape[1]):
            for k in range(0,  subchannels_in_channel.shape[2]):
                aux1 += an[int(subchannels_in_channel[i][j][k])-1]
                aux2 += pw[int(subchannels_in_channel[i][j][k])-1]
                if j == 0:
                    aux_x += xsiz[int(subchannels_in_channel[i][j][k])-1]
                if k == 0:
                    aux_y += ysiz[int(subchannels_in_channel[i][j][k])-1]

        new_an_pw[i][0] = aux1
        new_an_pw[i][1] = aux2
        new_sizes[i][0] = aux_x
        new_sizes[i][1] = aux_y
        if i == 0:
            new_loc_channels[0][0] = -bp/2 + new_sizes[0][0]/2
            new_loc_channels[0][1] = bp/2 - new_sizes[0][1]/2
        else:
            if ((i-1) // nchn_side) == (i // nchn_side):
                new_loc_channels[i][0] = new_loc_channels[i-1][0] + (new_sizes[i-1][0] + new_sizes[i][0])/2
                new_loc_channels[i][1] = new_loc_channels[i-1][1]
            else:
                new_loc_channels[i][0] = new_loc_channels[i-nchn_side][0]
                new_loc_channels[i][1] = new_loc_channels[i-nchn_side][1] - (new_sizes[i-nchn_side][1]+new_sizes[i][1])/2

    # creates data for the new channels

    channelsindextot = np.zeros(newchn_tot, dtype=int)
    for i in range(0, newchn_tot):
        channelsindextot[i] = (i+1)

    assemb_in_row = np.zeros(fa_numrow, dtype=int)
    acum_assemb_in_row = np.zeros(fa_numrow, dtype=int)
    newchn_in_core_row = np.zeros(fa_numrow, dtype=int)
    acum_newchn_in_core_row = np.zeros(fa_numrow, dtype=int)
    newchn_in_fa_row = np.zeros(fa_numrow, dtype=int)
    acum_newchn_in_fa_row = np.zeros(fa_numrow, dtype=int)

    # defines the magnitudes for the Card 2 to be edited and written

    card2_chan = np.zeros(newchn_tot, dtype=int)
    card2_an = np.zeros(newchn_tot, dtype=np.float64)
    card2_pw = np.zeros(newchn_tot, dtype=np.float64)
    card2_X = np.zeros(newchn_tot, dtype=np.float64)
    card2_Y = np.zeros(newchn_tot, dtype=np.float64)
    card2_XSIZ = np.zeros(newchn_tot, dtype=np.float64)
    card2_YSIZ = np.zeros(newchn_tot, dtype=np.float64)

    for i in range(0, fa_numrow):
        auxvar = 0
        for j in range(0, fa_numcol):
            if core_map[i][j] != 0:
                auxvar += 1

        assemb_in_row[i] = auxvar
        newchn_in_core_row[i] = auxvar * newchn_side
        newchn_in_fa_row[i] = auxvar * newchn

        if i == 0:

            acum_assemb_in_row[i] = assemb_in_row[i]
            acum_newchn_in_core_row[i] = newchn_in_core_row[i]
            acum_newchn_in_fa_row[i] = newchn_in_fa_row[i]

        else:
            acum_assemb_in_row[i] = acum_assemb_in_row[i-1] + assemb_in_row[i]
            acum_newchn_in_core_row[i] = acum_newchn_in_core_row[i-1] + newchn_in_core_row[i]
            acum_newchn_in_fa_row[i] = acum_newchn_in_fa_row[i-1] + newchn_in_fa_row[i]

    for i in range(0, newchn_tot):
        card2_chan[i] = i+1
        # TODO some lines should be added here so as to change the channel data depending on the type of the fa
        auxrow = 1

        for j in range(1, fa_numrow):
            if i+1 > acum_newchn_in_fa_row[j-1] and i+1 <=  acum_newchn_in_fa_row[j]:
                auxrow = j+1

            else:
                if i + 1 <= acum_newchn_in_fa_row[0]:
                    auxrow = 1

        if auxrow == 1:
            chanreset = i + 1

        else:
            chanreset = i + 1 - acum_newchn_in_fa_row[auxrow-2]

        auxrow2 = ((chanreset - 1) // newchn_in_core_row[auxrow - 1]) + 1
        chanreset2 = chanreset - newchn_in_core_row[auxrow - 1] * (auxrow2 - 1)
        aux_fa = int(((chanreset2 - 1) // newchn_side) + 1)
        chanreset3 = chanreset2 - (aux_fa - 1) * newchn_side
        # aux_fatype = core_map[auxrow - 1][aux_fa - 1]
        index_in_fa = chanreset3 + (auxrow2 - 1) * newchn_side
        card2_an[i] = new_an_pw[index_in_fa - 1][0]
        card2_pw[i] = new_an_pw[index_in_fa - 1][1]
        card2_XSIZ[i] = new_sizes[index_in_fa - 1][0]
        card2_YSIZ[i] = new_sizes[index_in_fa - 1][1]

        if auxrow == 1:
            card2_X[i] = new_loc_channels[index_in_fa - 1][0] + fa_cent[aux_fa - 1][0]
            card2_Y[i] = new_loc_channels[index_in_fa - 1][1] + fa_cent[aux_fa - 1][1]

        else:
            card2_X[i] = new_loc_channels[index_in_fa - 1][0] + fa_cent[acum_assemb_in_row[auxrow - 2] + aux_fa - 1][
                0]
            card2_Y[i] = new_loc_channels[index_in_fa - 1][1] + fa_cent[acum_assemb_in_row[auxrow - 2] + aux_fa - 1][
                1]

    # sets a new origin in the numeration for the channels

    if ngt > 0:
        print(gtpos)

    # creates TOTRODSROW TOTRODSCOL TOTCHANSROW TOTCHANSCOL

    totrodsrow_n = fa_numrow * newchn_side
    totrodscol_n = fa_numcol * newchn_side
    totchansrow_n = totrodsrow_n
    totchanscol_n = totrodscol_n
    linaux = lines[findheaderinline(lines, "TOTRODSROW TOTRODSCOL") + 1].split()
    totrodsrow_o = int(linaux[0])
    totrodscol_o = int(linaux[1])
    linaux = lines[findheaderinline(lines, "TOTCHANSROW TOTCHANSCOL") + 1].split()
    totchansrow_o = int(linaux[0])
    totchanscol_o = int(linaux[1])

    # gets NK - the number of gaps - from Card 3.1. Calculates the new number of gaps

    ngaps_tot = int(lines[findheaderinline(lines, "NK NDM2 NDM3") + 1].split()[0])
    old_gaps_in_fa = 2 * nchn_side * (nchn_side - 1)
    inner_gaps_in_fa = 2 * newchn_side * (newchn_side-1)
    newngaps_tot = int((totrodscol_n-1) * totrodsrow_n + totrodscol_n * (totrodsrow_n - 1)) + inner_gaps_in_fa * fa_num
    short_gap = free_sp + (dlev - 1) * pp  # dimensions for the long and short gap between assemblies
    long_gap = dlev * pp

    # Creates gap data. First it creates gap data for a single assembly (in the future, for every type of assembly)

    def findthechannelingaps(vgaps, val, time=1):
        # finds the first channel with number of channel val in the vector of gaps and returns the number of gap
        aux = 0
        clock = 1
        for i in range(0, old_gaps_in_fa):
            if vgaps[i][0] == val:
                if clock < time:
                    clock = clock +1
                else:
                    aux = i+1
                    break
        return aux

    coords2 = np.zeros(nchn_side - 1, dtype=np.float64)  # the other possible coordinate is already in coords
    coords2[0] = - bp / 2 + free_sp
    coords2[-1] = bp / 2 - free_sp

    for i in range(1, nchn_side - 2):
        coords2[i] = coords2[i - 1] + pp

    rod1 = int(0)
    rod2 = int(0)
    d1 = float(0)
    d2 = float(0)
    oldgap_type = []  # its final size should old_gaps_in_fa
    old_gap_connects = np.zeros((old_gaps_in_fa, 2), dtype=int)
    old_gap_gap = np.zeros(old_gaps_in_fa, dtype=np.float64)
    new_gap_connect = np.zeros((inner_gaps_in_fa, 2), dtype=int)
    new_gap_gaps = np.zeros(inner_gaps_in_fa, dtype=np.float64)
    new_loc_gaps = np.zeros((inner_gaps_in_fa, 2), dtype=np.float64)
    new_gap_lngts = np.zeros(inner_gaps_in_fa, dtype=np.float64)
    new_gap_dirs = []

    nrep = 2 * nchn_side - 1

    for i in range(0, old_gaps_in_fa):
        if i <= old_gaps_in_fa - nchn_side:
            if (i + 1) % nrep == 0:
                oldgap_type.append('y')
                old_gap_connects[i][0] = nchn_side*((i+1) // nrep)
                old_gap_connects[i][1] = old_gap_connects[i][0] + nchn_side
                old_gap_gap[i] = free_sp
                rod1 = rods_for_subchannel[old_gap_connects[i][0] - 1][1][0]
                old_gap_gap[i] -= 0.5 * od_rods[rod1 - 1]

            else:
                if ((i+1) % nrep) % 2 == 1:
                    oldgap_type.append('x')
                    old_gap_connects[i][0] = ((i+1) // nrep) * nchn_side + (((i+1) % nrep) // 2) + 1
                    old_gap_connects[i][1] = old_gap_connects[i][0] + 1
                    if i + 1 <= nrep:
                        old_gap_gap[i] = free_sp
                        rod1 = rods_for_subchannel[old_gap_connects[i][0] - 1][1][1]
                        old_gap_gap[i] -= 0.5 * od_rods[rod1 - 1]
                    else:
                        old_gap_gap[i] = pp
                        rod1 = rods_for_subchannel[old_gap_connects[i][0] - 1][0][1]
                        rod2 = rods_for_subchannel[old_gap_connects[i][0] - 1][1][1]
                        old_gap_gap[i] -= 0.5 * (od_rods[rod1 - 1] + od_rods[rod2 - 1])

                else:
                    oldgap_type.append('y')
                    old_gap_connects[i][0] = ((i + 1) // nrep) * nchn_side + (((i + 1) % nrep) // 2)
                    old_gap_connects[i][1] = old_gap_connects[i][0] + nchn_side
                    if (i + 1) % nrep == 2:
                        old_gap_gap[i] = free_sp
                        rod1 = rods_for_subchannel[old_gap_connects[i][0] - 1][1][1]
                        old_gap_gap[i] -= 0.5 * od_rods[rod1 - 1]
                    else:
                        old_gap_gap[i] = pp
                        rod1 = rods_for_subchannel[old_gap_connects[i][0] - 1][1][0]
                        rod2 = rods_for_subchannel[old_gap_connects[i][0] - 1][1][1]
                        old_gap_gap[i] -= 0.5 * (od_rods[rod1 - 1] + od_rods[rod2 - 1])

        else:
            oldgap_type.append('x')
            old_gap_connects[i][0] = (nchn_side-1) * nchn_side + ((i + 1) % nrep)
            old_gap_connects[i][1] = old_gap_connects[i][0] + 1
            old_gap_gap[i] = free_sp
            rod1 = rods_for_subchannel[old_gap_connects[i][0] - 1][0][1]
            old_gap_gap[i] -= 0.5 * od_rods[rod1 - 1]

    nrep = 2 * newchn_side - 1

    for i in range(0, inner_gaps_in_fa):
        aux = np.float64(0)
        if i <= inner_gaps_in_fa - newchn_side:
            if (i + 1) % nrep == 0:
                new_gap_dirs.append('y')
                new_gap_connect[i][0] = newchn_side * ((i + 1) // nrep)
                new_gap_connect[i][1] = new_gap_connect[i][0] + newchn_side
            else:
                if ((i + 1) % nrep) % 2 == 1:
                    new_gap_dirs.append('x')
                    new_gap_connect[i][0] = ((i + 1) // nrep) * newchn_side + (((i + 1) % nrep) // 2) + 1
                    new_gap_connect[i][1] = new_gap_connect[i][0] + 1
                else:
                    new_gap_dirs.append('y')
                    new_gap_connect[i][0] = ((i + 1) // nrep) * newchn_side + (((i + 1) % nrep) // 2)
                    new_gap_connect[i][1] = new_gap_connect[i][0] + newchn_side

        else:
            new_gap_dirs.append('x')
            new_gap_connect[i][0] = (newchn_side - 1) * newchn_side + ((i + 1) % nrep)
            new_gap_connect[i][1] = new_gap_connect[i][0] + 1

        if new_gap_dirs[i] == 'x':
            for j in range(0, dlev):
                search = subchannels_in_channel[new_gap_connect[i][0]-1][j][dlev - 1]
                aux += old_gap_gap[findthechannelingaps(old_gap_connects, search, time=1) - 1]
            new_gap_lngts[i] = new_loc_channels[new_gap_connect[i][1]-1][0] - new_loc_channels[new_gap_connect[i][0]-1][0]
            new_loc_gaps[i][0] = new_loc_channels[new_gap_connect[i][0]-1][0] + new_sizes[new_gap_connect[i][0]-1][0]/2
            if abs(new_loc_gaps[i][0]) < 1e-6:
                new_loc_gaps[i][0] = 0.0
            new_loc_gaps[i][1] = new_loc_channels[new_gap_connect[i][0]-1][1]

        if new_gap_dirs[i] == 'y':
            for j in range(0, dlev):
                search = subchannels_in_channel[new_gap_connect[i][0]-1][dlev-1][j]
                aux += old_gap_gap[findthechannelingaps(old_gap_connects, search, time=2) - 1]
            new_gap_lngts[i] = new_loc_channels[new_gap_connect[i][0]-1][1] - new_loc_channels[new_gap_connect[i][1]-1][1]
            new_loc_gaps[i][0] = new_loc_channels[new_gap_connect[i][0]-1][0]
            new_loc_gaps[i][1] = new_loc_channels[new_gap_connect[i][0]-1][1] - new_sizes[new_gap_connect[i][0]-1][1]/2
            if abs(new_loc_gaps[i][1]) < 1e-6:
                new_loc_gaps[i][1] = 0.0

        new_gap_gaps[i] = aux

    nono = int(lines[findheaderinline(lines, "NCHN NONO")+1].split()[2])
    new_msim = nono*newchn_tot

    # Reads NCD in Card 7.1, gets the different CDL and J positions from Card 7.2

    ncd = int(lines[findheaderinline(lines, "NCD NGT") + 1].split()[0])
    ngrids = int(ncd / ((nchn_tot + 1) // 12))
    grid_cdl = np.zeros((ngrids, 1), dtype=float)
    grid_j = np.zeros((ngrids, 1), dtype=int)
    new_ncd = ngrids * (((newchn_tot - 1) // 12) + 1)

    # gets the name of the .hdf5 and .vtk files from Card 17.1

    line_aux = lines[findheaderinline(lines, "HDF5_NAME VTK_NAME") + 1].split()
    namehdf5 = line_aux[0].split('.')[0]
    namevtk = line_aux[1].split('.')[0]

    # gets a map of the full core from card 17.2

    newrodsmap = np.zeros((totrodsrow_n, totrodscol_n), dtype=int)
    for i in range(0, totrodsrow_n):
        line_aux = lines[findheaderinline(lines, "Assembly Map") + 1 + (i // newchn_side)].split()
        for j in range(0, totrodscol_n):
            newrodsmap[i][j] = int(line_aux[j // newchn_side])

    # ------------------------WRITING--------------------------------------------------- #

    # Substitutes the number of channels in Group 2

    line_aux = lines[findheaderinline(lines, "NCH NDM2") + 1].split()
    line_aux[0] = str(newchn_tot)
    line_aux = '     ' + '    '.join(line_aux) + '\n'  # creates a sole string with the appropriate format
    lines[findheaderinline(lines, "NCH NDM2") + 1] = line_aux  # stores the modified line into its position

    # Deletes the excess of lines in Card 2.2

    removeexcesslines(lines, findheaderinline(lines, "I AN PW", time=1), nchn, newchn_tot)

    # Edits Card 2.2 lines

    for i in range(0, newchn_tot):
        line_aux = lines[findheaderinline(lines, "I AN PW", time=1) + 1 + i].split()
        line_aux[0] = str(i + 1)
        line_aux[1] = format_e(card2_an[i])
        line_aux[2] = format_e(card2_pw[i])
        line_aux[6] = format_e(card2_X[i])
        line_aux[7] = format_e(card2_Y[i])
        line_aux[8] = format_e(card2_XSIZ[i])
        line_aux[9] = format_e(card2_YSIZ[i])
        line_aux = '     ' + '   '.join(line_aux) + '\n'
        lines[findheaderinline(lines, "I AN PW", time=1) + 1 + i] = line_aux

    # Changes the number of gaps in Card 3.1

    line_aux = lines[findheaderinline(lines, "NK NDM2") + 1].split()
    line_aux[0] = str(newngaps_tot)
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "NK NDM2") + 1] = line_aux

    # Deletes excess of gaps in Card 3.3

    removeexcesslines(lines, findheaderinline(lines, "K IK JK", time=1), 2+2*ngaps_tot, 2+2*newngaps_tot)

    # Deletes excess of gaps in Card 3.3.5

    removeexcesslines(lines, findheaderinline(lines, "K X Y NORM", time=1), ngaps_tot, newngaps_tot)

    # Changes NCHN in Card 4.2

    line_aux = lines[findheaderinline(lines, "ISEC    NCHN  NONO") + 1].split()
    line_aux[1] = str(newchn_tot)
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "ISEC    NCHN  NONO") + 1] = line_aux

    # Deletes excess lines in Card 4.4

    removeexcesslines(lines, findheaderinline(lines, "KCHA KCHA", time=1), nchn_tot, newchn_tot)

    # Changes IWDE in Card 4.5

    line_aux = lines[findheaderinline(lines, "IWDE") + 1].split()
    line_aux[0] = str(newchn_tot)
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "IWDE") + 1] = line_aux

    # Changes MSIM in Card 4.6

    line_aux = lines[findheaderinline(lines, "MSIM") + 1].split()
    line_aux[0] = str(new_msim)
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "MSIM") + 1] = line_aux

    # Substitutes NCD in Card 7.1. Creates the new values to store in Card 7.2

    line_aux = lines[findheaderinline(lines, "NCD NGT") + 1].split()
    line_aux[0] = str(new_ncd)
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "NCD NGT") + 1] = line_aux
    clock = int(0)

    for i in range(0, ncd):
        if i == 0:
            grid_cdl[0] = float(lines[findheaderinline(lines, "CDL J") + 1].split()[0])
            grid_j[0] = int(lines[findheaderinline(lines, "CDL J") + 1].split()[1])

        else:
            if int(lines[findheaderinline(lines, "CDL J") + 1 + i].split()[1]) != grid_j[clock] and clock < ngrids - 1:
                grid_cdl[clock + 1] = float(lines[findheaderinline(lines, "CDL J") + 1 + i].split()[0])
                grid_j[clock + 1] = int(lines[findheaderinline(lines, "CDL J") + 1 + i].split()[1])
                clock = clock + 1

    # Removes excessive lines in Card 7.2

    removeexcesslines(lines, findheaderinline(lines, "CDL J CD1", time=1), ncd, new_ncd)

    # Gives new values in Card 7.2 and re-writes it

    lines_per_grid = int(new_ncd / ngrids)
    for i in range(0, new_ncd):
        line_aux = lines[findheaderinline(lines, "CDL J CD1", time=1) + 1 + i].split()
        line_aux[0] = str(float(grid_cdl[i // lines_per_grid]))
        line_aux[1] = str(int(grid_j[i // lines_per_grid]))
        line_aux[2] = str(12 * (i % lines_per_grid) + 1)
        line_aux[3] = str(12 * (i % lines_per_grid) + 2)
        line_aux[4] = str(12 * (i % lines_per_grid) + 3)
        line_aux[5] = str(12 * (i % lines_per_grid) + 4)
        line_aux[6] = str(12 * (i % lines_per_grid) + 5)
        line_aux[7] = str(12 * (i % lines_per_grid) + 6)
        line_aux[8] = str(12 * (i % lines_per_grid) + 7)
        line_aux[9] = str(12 * (i % lines_per_grid) + 8)
        line_aux[10] = str(12 * (i % lines_per_grid) + 9)
        line_aux[11] = str(12 * (i % lines_per_grid) + 10)
        line_aux[12] = str(12 * (i % lines_per_grid) + 11)
        line_aux[13] = str(12 * (i % lines_per_grid) + 12)
        if newchn_tot % 12 != 0:
            if (i + 1) % lines_per_grid == 0:
                for j in range(0, 12 - (newchn_tot % 12)):
                    line_aux[-1 - j] = str(0)
        line_aux = '     ' + '    '.join(line_aux) + '\n'
        lines[findheaderinline(lines, "CDL J CD1", time=1) + 1 + i] = line_aux

    # Changes NRRD in Card 8.1

    line_aux = lines[findheaderinline(lines, "NRRD NSRD", time=1) + 1].split()
    line_aux[0] = str(newnrod_tot)
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "NRRD NSRD", time=1) + 1] = line_aux

    # Changes NRT1 in Card 8.6

    line_aux = lines[findheaderinline(lines, "NRT1 NST1", time=1) + 1].split()
    line_aux[1] = str(newnrod_tot)
    line_aux = '     ' + '    '.join(line_aux) + '\n'  # creates a sole string with the appropriate format
    lines[findheaderinline(lines, "NRT1 NST1", time=1) + 1] = line_aux  # stores the modified line into its position

    # Deletes excess of lines in Card 8.7

    removeexcesslines(lines, findheaderinline(lines, "IRTB1 IRTB2"), ((nrods - 1) // 12) + 1,
                      ((newnrod_tot - 1) // 12) + 1)
    if newnrod_tot % 12 != 0:
        line_aux = lines[findheaderinline(lines, "IRTB1 IRTB2", time=1) + ((newnrod_tot - 1) // 12) + 1].split()
        for i in range(0, 12 - (newnrod_tot % 12)):
            line_aux[-i - 1] = "  "

        line_aux = '     ' + '     '.join(line_aux) + '\n'  # creates a sole string with the appropriate format
        lines[findheaderinline(lines, "IRTB1 IRTB2", time=1) + ((newnrod_tot - 1) // 12) + 1] = line_aux

    # Deletes Card 9.6 and 9.7

    if ngt > 0:
        start = findheaderinline(lines, "Card 9.6")-1
        n_oldlines = findnextto(lines, "Card 9.6", "********") - start - 1
        removeexcesslines(lines, start, n_oldlines, 0)

    # Changes NMAT in Card 10.1

    if ngt > 0:
        line_aux = lines[findheaderinline(lines, "NMAT NDM2", time=1) + 1].split()
        line_aux[0] = "1"
        line_aux = '     ' + '    '.join(line_aux) + '\n'
        lines[findheaderinline(lines, "NMAT NDM2", time=1) + 1] = line_aux

    # Changes NAXP in Card 11.1

    line_aux = lines[findheaderinline(lines, "NQA NAXP MNXN", time=1) + 1].split()
    line_aux[1] = str(1)
    line_aux = '     ' + '   '.join(line_aux) + '\n'  # creates a sole string with the appropriate format
    lines[findheaderinline(lines, "NQA NAXP MNXN",
                           time=1) + 1] = line_aux  # stores the modified line into its position

    # Deletes second axial profile (repeated Cards 11.3 and 11.4, that is included when there exist guide tubes.
    # In future versions this could be linked to the number of axial profiles left.

    if ngt > 0:
        deletebetweencards(lines, "Card 11.3", "Card 11.7", 2)

    # Changes number of boundary conditions in Card 13.1

    line_aux = lines[findheaderinline(lines, "NBND NKBD NFUN", time=1) + 1].split()
    line_aux[0] = str(2*newchn_tot)
    line_aux = '     ' + '   '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "NBND NKBD NFUN", time=1) + 1] = line_aux

    # deletes excess of boundary conditions in card 13.4

    removeexcesslines(lines, findheaderinline(lines, "IBD1 IBD2", time=1), nchn_tot, newchn_tot)
    removeexcesslines(lines, findheaderinline(lines, "outlet b.c.", time=1), nchn_tot, newchn_tot)

    # Changes names of the .hdf5 and .vtk files in Card 17.1
    
    line_aux = [namehdf5 + '_dlev' + str(dlev) + '.hdf5', namevtk + '_dlev' + str(dlev) + '.vtk']
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "HDF5_NAME VTK_NAME") + 1] = line_aux
    
    # Changes the rod map dimensions in Card 17.2

    line_aux = lines[findheaderinline(lines, "TOTRODSROW TOTRODSCOL", time=1) + 1].split()
    line_aux[0], line_aux[1] = str(totrodsrow_n), str(totrodscol_n)
    line_aux = '     ' + '   '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "TOTRODSROW TOTRODSCOL", time=1) + 1] = line_aux

    # Changes the channel map dimensions in Card 17.3

    line_aux = lines[findheaderinline(lines, "TOTCHANSROW TOTCHANSCOL", time=1) + 1].split()
    line_aux[0], line_aux[1] = str(totchansrow_n), str(totchanscol_n)
    line_aux = '     ' + '   '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "TOTCHANSROW TOTCHANSCOL", time=1) + 1] = line_aux

    # Deletes previous rod maps and channel maps

    removeexcesslines(lines, findcardinline(lines, "Card 17.4 - Rod Map"), totrodsrow_o, totrodsrow_n)
    removeexcesslines(lines, findcardinline(lines, "Card 17.4 - Channel Map"), totchansrow_o, totchansrow_n)

    for i in range(0, totrodsrow_n):
        line_aux = []
        for j in range(0, totrodscol_n):
            line_aux.append(str(newrodsmap[i][j]))

        line_aux = '     ' + '   '.join(line_aux) + '\n'
        lines[findheaderinline(lines, "Card 17.4 - Rod Map", time=1) + 1+i] = line_aux
        lines[findheaderinline(lines, "Card 17.4 - Channel Map", time=1) + 1 + i] = line_aux

    # TODO remake the new core map

    # ---------------------------------------END OF MAIN--------------------------------------------------

    file = open('new_deck.inp', 'w')
    file.writelines(lines)
    file.close()

    # TODO Assess that it is compatible with different assembly types and power profiles
    # TODO correct the alignment when writing lines (e.g. in channels or gaps cards) -> deck.inp file is more readable


main()

