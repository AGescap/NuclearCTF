import numpy as np
import sys
import math

'''
This Python script is aimed at processing an input file of CTF core simulation code, which has been generated by CTF preprocessor [1]. 
The input of this script will be a Core input file -i.e. more than one Fuel Assembly- The output of this file will be a  new CTF input file where previous subchannels
have been merged into larger ones. This code is not much pythonic, but that makes it easier to be read by a Matlab user. Many of the instructions assume
that there are no empty lines in the begginning of a Card, whereas most of them are ok with blank lines at the end of a Card.

(*)It is likely that the script will not work for core arrays with one row of fuel assemblies. Is this is proven, a special
   case could be created, given that many processes in the new gaps building would simplify considerably
 
Author: Álvaro González Escapa
Institution: Polytechnic University of Madrid
Python version: 3.8 


References:
[1]. Avramova, Maria N. and Salko, Robert (2016). CTF preprocessor's user manual. Pennsylvania State University. Reactor dynamics and fuel management group

'''


def findcardinline(doc, string, time=1):
    # so as to count the iterations. Caution is needed with the string here, because if one types
    # e.g. Card 3.3., it will find both Card 3.3 or Card 3.3.5.
    # With the variable time, it can now look for the n-th time that the Card appears (like in axial or radial profiles)
    cont = 0
    locus = -1
    clock = 1
    for linex in doc:

        # find returns the first position of the sequence that appears in the line. Should it not appear,
        # find returns -1. The exact value does not matter, only its presence

        if linex.find(string) >= 0:
            if clock < time:
                clock = clock + 1
                cont = cont + 1
            else:
                locus = cont
                break
        else:
            cont = cont + 1
    return locus


def findheaderinline(doc, string, time=1, separator=" "):
    cont = 0
    locus = -1
    clock = 1
    for linex in doc:
        if linex.replace(separator, "").find(string.replace(separator, "")) >= 0:
            if clock < time:
                clock = clock+1
                cont = cont + 1
            else:
                locus = cont
                break
        else:
            cont = cont + 1
    return locus


def findnextto(doc, string1, string2, time1=1, time2=1):
    start = int(findheaderinline(doc, string1, time=time1))
    aux_doc = [None]*(len(doc) - start)
    for i in range(0, len(doc) - start):
        aux_doc[i] = doc[i+start]

    finish = findheaderinline(aux_doc, string2, time=time2) + start
    return finish


# removeexcesslines takes a list of strings (the result of readlines method), sets an origin
# (ideally, a variables header) and from that, counts PRIOR lines -like the ones in Group 4 of deck.inp in CTF-
# in the new situation, ACTUAL lines must be conserved, from the position BEGIN, and thus REMOVE lines must be erased


def removeexcesslines(doc, begin, prior, actual):
    remove = prior - actual
    for i in range(0, remove):
        doc.pop(begin+actual+1)


def rewritesomelines(doc, begin, piece):
    # rewrites all the lines in piece. First one replaced is the next one to "begin"
    for i in range(0, len(piece)):
        doc[begin+1+i] = piece[i] + " \n"


# deletebetweencards looks for the position number time 1 of the Card 1 and deletes everything
# (including Card1) until it finds Card 2 (for the time2-th occasion)
def deletebetweencards(doc, card1, card2, time1=1, time2=1):
    pos1 = findcardinline(doc, card1, time1)
    pos2 = findcardinline(doc, card2, time2)
    for i in range(0, pos2 - pos1):
        doc.pop(pos1)


def chanindex_xy(x, y, numchannelside):
    # chanindex: from the x, y position (origin in bottom left corner), gets the index of the channel.
    # Numeration begins at top left and goes first rightwards and then downwards.
    # System of reference: x increases to the right, y increases from the bottom to the top
    return x+(numchannelside - y)*numchannelside


def retrieve_xy(index, numchannelside):
    # retrieve_xy: from the index and the number of channels per side, gets x and y (origin in bottom left corner). This
    # does not apply exclusively for subchannel, but for any homogenization
    y = numchannelside - (index - 1) // numchannelside
    x = index - (numchannelside - y)*numchannelside
    return [x, y]


def refchannel(numchannel, dlevel, n_sbchn_side):
    # f rom the number of a newly created channel (1,2,...N/Dlev**2), gets global index of its top left channel
    new_chn_per_side = n_sbchn_side / dlevel
    [x, y] = retrieve_xy(numchannel, new_chn_per_side)
    return 1 + (x-1) * dlevel + (new_chn_per_side - y) * n_sbchn_side * dlevel


def format_e(n):    # This function allows to write a float as a string with scientific notation
    a = '%E' % n
    return a.split('E')[0].rstrip('0').rstrip('.') + 'E' + a.split('E')[1]


def ret_FA(numcols, numfa):
    '''
    This function returns the position
    '''
    a = [int((numfa - 1) // numcols + 1), int(numfa - numcols*(((numfa - 1) // numcols + 1)-1))]
    return a

def main():
    '''
    Here the approach is that of deducting all the subchannel properties from prepro data, given that some features as
    the guide tubes location are more explicitly given in those files, rather than in deck.inp (the coordinates appear,
    whereas in deck.inp a search should be done in the radial power profile)
    '''
    # open the deck file and also the prepro files
    file = open("deck.inp", "r")
    lines = file.readlines()
    file.close()

    file_control = open("control.inp", "r")
    l_control = file_control.readlines()
    file_control.close()

    file_geo = open("geo.inp", "r")
    l_geo = file_geo.readlines()
    file_geo.close()

    file_assem = open("assem.inp", "r")
    l_assem = file_assem.readlines()
    file_assem.close()

    file_power = open("power.inp", "r")
    l_power = file_power.readlines()
    file_power.close()

    '''
    Begin the READS and simple Calculations, not DELETES nor WRITES yet
    '''

    # gets number of fuel assemblies in assem.inp
    fa_num = int(l_geo[findheaderinline(l_geo, "*Number of fuel assemblies")+1].split()[0])
    fa_types = int(l_geo[findheaderinline(l_geo, "NUMBER OF FUEL ASSEMBLY TYPES") + 1].split()[0])
    fa_numcol = int(l_geo[findheaderinline(l_geo, "CORE MESH X Y")+1].split()[0])
    fa_numrow = int(l_geo[findheaderinline(l_geo, "CORE MESH X Y")+1].split()[1])

    # gets rods number in the assembly

    nfrods = np.zeros(fa_types, dtype=int)
    nfrods[0] = int(l_assem[findheaderinline(l_assem, "Number of fuel rods")+1].split()[0])

    # gets number of guidetubes

    ngt = np.zeros(fa_types, dtype=int)
    ngt[0] = int(l_assem[findheaderinline(l_assem, "Number of guide tubes/water rods") + 1].split()[0])

    # gets the old number of channels in the deck.inp

    nchn_tot = int(lines[findheaderinline(lines, "NCH NDM2 NDM3")+1].split()[0])

    # total number of rods, rods per side, channels per side, discretization level

    nrods = nfrods[0] + ngt[0]          # so far, this figure will remain constant through the different FA's
    nrods_side = int(np.sqrt(nrods))
    nchn_side = nrods_side + 1
    nchn = nchn_side**2
    dlev = 2

    if nchn_side % dlev != 0:
        print("ERROR: The original number of channels per side is not divisible by dlev: " + str(dlev) + "\n")
        sys.exit(1)

    # new number of channels in the new, homogenized bundle

    newchn = int(nchn/(dlev**2))
    newchn_side = int(nchn_side/dlev)
    newchn_tot = fa_num*newchn
    newnrod_tot = newchn_tot

    # gets bundle pitch and converts it into m

    bp = np.float64(l_assem[findheaderinline(l_assem, "Bundle pitch") + 1].split()[0])
    bp = bp / 1000

    # gets pin pitch and converts it into mm

    pp = float(l_assem[findheaderinline(l_assem, "Pin pitch") + 1].split()[0])
    pp = pp / 1000

    # defines useful magnitudes

    free_sp = (bp - (nrods_side - 1) * pp) / 2
    inner_gaps_in_fa = 2 * newchn_side * (newchn_side - 1)
    totrodsrow_n = fa_numrow * newchn_side
    totrodscol_n = fa_numcol * newchn_side
    totchansrow_n = totrodsrow_n
    totchanscol_n = totrodscol_n
    linaux = lines[findheaderinline(lines, "TOTRODSROW TOTRODSCOL") + 1].split()
    totrodsrow_o = int(linaux[0])
    linaux = lines[findheaderinline(lines, "TOTCHANSROW TOTCHANSCOL") + 1].split()
    totchansrow_o = int(linaux[0])

    # gets position of guide tubes if there are any. with the origin in top left corner of the FA,
    # the "0th" position marks the row and "1st" position, the column

    fr_id = np.zeros(fa_types, dtype=np.float64)
    fr_id[0] = float(l_assem[findheaderinline(l_assem, "Cladding inner diameter") + 1].split()[0])
    fr_id[0] = fr_id / 1000
    fr_od = np.zeros(fa_types, dtype=np.float64)
    fr_od[0] = float(l_assem[findheaderinline(l_assem, "Cladding outer diameter") + 1].split()[0])
    fr_od[0] = fr_od / 1000

    fr_clad_mat = []
    fr_clad_mat.append(l_assem[findheaderinline(l_assem, "Cladding material") + 1].split()[0])
    gt_mat = []

    gapcond = np.zeros(fa_types, dtype=float)
    gapcond[0] = float(l_assem[findheaderinline(l_assem, "Constant gap conductance")+1].split()[0])
    gtpos = np.zeros((fa_types, nrods, 2), dtype=int)
    ftds = np.zeros(fa_types, dtype=float)
    gt_id = np.zeros(fa_types, dtype=float)
    gt_od = np.zeros(fa_types, dtype=float)

    rodtype = np.zeros((fa_types, nrods_side, nrods_side), dtype=int)
    fp_diam = np.zeros(fa_types, dtype=float)

    fp_diam[0] = float(l_assem[findheaderinline(l_assem, "Fuel pellet diameter") + 1].split()[0])  # diam of fuel pellet
    fp_diam[0] = fp_diam[0] / 1000
    ftds[0] = float(l_assem[findheaderinline(l_assem, "Theoretical density of the fuel pellet") + 1].split()[0])

    if ngt[0] > 0:

        for i in range(ngt[0]):
            linaux = l_assem[findheaderinline(l_assem, "Use X Y format") + 1+i].split()
            gtpos[0][i][0] = int(linaux[0])
            gtpos[0][i][1] = int(linaux[1])
            rodtype[0][int(linaux[0]) - 1][int(linaux[1]) - 1] = 1

        gt_od[0] = float(l_assem[findheaderinline(l_assem, "Outer diameter of guide tube/water rod") + 1].split()[0])
        gt_od[0] = gt_od[0]/1000
        gt_id[0] = float(l_assem[findheaderinline(l_assem, "Inner diameter of guide tube/water rod") + 1].split()[0])
        gt_id[0] = gt_id[0] / 1000
        gt_mat.append(l_assem[findheaderinline(l_assem, "Guide tube/water rod material") + 1].split()[0])

        print(gt_od[0])
    else:
        gt_mat.append("X")

    if fa_types > 1:
        file_extra_fa = open("ExtraFA.inp", "r")
        l_extra_fa = file_extra_fa.readlines()
        file_extra_fa.close()
        for i in range(0, fa_types - 1):
            ngt[i + 1] = int(l_extra_fa[findheaderinline(l_extra_fa, "Number of guide tubes/water rods",
                                                         time=i+1) + 1].split()[0])
            ftds[i + 1] = float(l_extra_fa[findheaderinline(l_extra_fa, "Theoretical density of the fuel pellet",
                                                            time=i+1) + 1].split()[0])
            gapcond[i + 1] = float(l_extra_fa[findheaderinline(l_extra_fa, "Constant gap conductance",
                                                            time=i+1) + 1].split()[0])
            fr_clad_mat.append(l_extra_fa[findheaderinline(l_extra_fa, "Cladding material", time=i+1) + 1].split()[0])
            if ngt[i + 1] > 0:
                gt_id[i + 1] = float(l_extra_fa[findheaderinline(l_extra_fa,
                                                                 "Inner diameter of guide tube/water rod",
                                                                 time=i+1) + 1].split()[0])
                gt_od[i + 1] = float(l_extra_fa[findheaderinline(l_extra_fa,
                                                                 "Outer diameter of guide tube/water rod",
                                                                 time=i+1) + 1].split()[0])
                gt_mat.append(l_extra_fa[findheaderinline(l_extra_fa,
                                                          "Guide tube/water rod material",
                                                           time=i + 1) + 1].split()[0])
                for j in range(0, ngt[i + 1]):
                    linaux = l_extra_fa[findheaderinline(l_extra_fa, "Use X Y format",
                                                         time=i+1) + 1+j].split()
                    gtpos[i + 1][j][0] = int(linaux[0])
                    gtpos[i + 1][j][1] = int(linaux[1])
                    rodtype[i + 1][int(linaux[0]) - 1][int(linaux[1]) - 1] = 1

            else:
                gt_mat.append("X")


    fa_types_list = np.zeros(fa_num, dtype=int)

    # core map has the core map, with the positions and the indexes

    core_map = np.zeros((fa_numrow, fa_numcol), dtype=int)
    numb_core_map = np.zeros((fa_numrow, fa_numcol), dtype=int)
    core_centX = np.zeros(fa_numcol, dtype=np.float64)
    core_centY = np.zeros(fa_numrow, dtype=np.float64)

    for i in range(0, fa_numcol):
        core_centX[i] = ((i + 1) - 0.5 - float(fa_numcol) / 2) * bp

    for i in range(0, fa_numrow):
        core_centY[i] = ((i + 1) - 0.5 - float(fa_numcol) / 2) * bp

    # edit fa_transl, edit core_map

    cont_a = 1
    cont_b = 0
    for i in range(fa_numrow):
        linaux = (l_geo[findheaderinline(l_geo, "FUEL ASSEMBLY MAP") + 2+i].split())
        linaux2 = lines[findheaderinline(lines, "Assembly Map") + 1 + i].split()
        for j in range(fa_numcol):
            if int(linaux[j+1]) != 0:
                fa_types_list[cont_b] = int(linaux[j+1])
                cont_b = cont_b + 1

            core_map[i][j] = int(linaux[j+1])
            cont_a = cont_a + 1
            numb_core_map[i][j] = int(linaux2[j])

    # now, for every FA type, generic info about channels (An, Pw, XSIZ, YSIZ) should be created
    # creates an array to store the outer diameters of the rods

    od_s = np.zeros((fa_types, 2), dtype=float)
    od_s[0][0] = fr_od[0]

    if ngt[0] > 0:
        od_s[0][1] = gt_od[0]

    od_rods = np.ones((fa_types, nrods_side, nrods_side), dtype=float)

    for i in range(0, fa_types):
        od_s[i][0] = fr_od[i]
        if ngt[i] > 0:
            od_s[i][1] = gt_od[i]
        for j in range(0, nrods_side):
            for k in range(0, nrods_side):
                od_rods[i][j][k] = od_s[i][rodtype[i][j][k]]

    # creates an array with the subchannels that correspond to a rod

    subchannels_in_rod = np.zeros((nrods_side, nrods_side, 2, 2, 2), dtype=int)
    rods_for_subchannel = -1 * np.ones((nchn_side, nchn_side, 2, 2, 2), dtype=int)

    for i in range(0, nrods_side):
        for j in range(0, nrods_side):
            subchannels_in_rod[i][j][0][0] = [i, j]
            subchannels_in_rod[i][j][0][1] = [i, j + 1]
            subchannels_in_rod[i][j][1][0] = [i + 1, j]
            subchannels_in_rod[i][j][1][1] = [i + 1, j + 1]

    for i in range(0, nchn_side):
        for j in range(0, nchn_side):
            if i != 0:
                if i != nchn_side - 1:
                    if j != 0:
                        if j != nchn_side - 1:
                            rods_for_subchannel[i][j][0][0] = [i - 1, j - 1]
                            rods_for_subchannel[i][j][0][1] = [i - 1, j]
                            rods_for_subchannel[i][j][1][0] = [i, j - 1]
                            rods_for_subchannel[i][j][1][1] = [i, j]
                        else:
                            rods_for_subchannel[i][j][0][0] = [i - 1, j - 1]
                            rods_for_subchannel[i][j][1][0] = [i, j - 1]

                    else:
                        rods_for_subchannel[i][j][0][1] = [i - 1, j]
                        rods_for_subchannel[i][j][1][1] = [i, j]

                else:
                    if j != 0:
                        if j != nchn_side - 1:
                            rods_for_subchannel[i][j][0][0] = [i - 1, j - 1]
                            rods_for_subchannel[i][j][0][1] = [i - 1, j]

                        else:
                            rods_for_subchannel[i][j][0][0] = [i - 1, j - 1]

                    else:
                        rods_for_subchannel[i][j][0][1] = [i - 1, j]

            else:
                if j != 0:
                    if j != nchn_side - 1:
                        rods_for_subchannel[i][j][1][0] = [i, j - 1]
                        rods_for_subchannel[i][j][1][1] = [i, j]

                    else:
                        rods_for_subchannel[i][j][1][0] = [i, j - 1]

                else:
                    rods_for_subchannel[i][j][1][1] = [i, j]

    # creates a matrix to store the data of the subchannels, so they can be merged afterwards

    xsiz = np.zeros(nchn_side, dtype=np.float64)
    ysiz = np.zeros(nchn_side, dtype=np.float64)
    new_xsiz = np.zeros(newchn_side, dtype=np.float64)
    new_ysiz = np.zeros(newchn_side, dtype=np.float64)

    xsiz[0] = free_sp
    ysiz[0] = free_sp
    xsiz[-1] = free_sp
    ysiz[-1] = free_sp

    new_xsiz[0] = free_sp + (dlev - 1) * pp
    new_xsiz[-1] = free_sp + (dlev - 1) * pp
    new_ysiz[0] = free_sp + (dlev - 1) * pp
    new_ysiz[-1] = free_sp + (dlev - 1) * pp

    for i in range(1, nchn_side - 1):
        xsiz[i] = pp
        ysiz[i] = pp

    for i in range(1, newchn_side - 1):
        new_xsiz[i] = dlev * pp
        new_ysiz[i] = dlev * pp

    an = np.zeros((nchn_side, nchn_side), dtype=np.float64)
    an_0 = np.zeros((nchn_side, nchn_side), dtype=np.float64)
    gapsX_gap = np.zeros((fa_types, nchn_side, nchn_side - 1), dtype=np.float64)
    gapsY_gap = np.zeros((fa_types, nchn_side - 1, nchn_side), dtype=np.float64)

    for i in range(0, nchn_side):
        for j in range(0, nchn_side):
            an_0[i][j] = xsiz[j] * ysiz[i]

    pw = np.zeros((nchn_side, nchn_side), dtype=np.float64)

    # gives values to the subchannel data

    new_coords = np.zeros(newchn_side, dtype=np.float64)
    new_coords[0] = -bp / 2 + (free_sp + (dlev - 1) * pp) / 2
    new_coords[-1] = bp / 2 - (free_sp + (dlev - 1) * pp) / 2

    for i in range(1, newchn_side - 1):
        new_coords[i] = -bp / 2 + free_sp + (dlev - 1) * pp + dlev * pp / 2 + (i - 1) * dlev * pp

    # edits nominal area and wet perimeter for the channels

    # creates an array that stores the number of subchannels that belong to the new channel
    subchannels_in_channel = np.zeros((newchn_side, newchn_side, dlev, dlev, 2), dtype=int)
    for i in range(0, nchn_side):
        for j in range(0, nchn_side):
            subchannels_in_channel[i // dlev][j // dlev][i % dlev][j % dlev] = [i, j]

    # defines a function that finds if a subchannel (subch) is contained in a certain new channel that
    # will contain dlev*dlev subchannels

    def findsubchannelinchannel(sub2chan, subch):
        aux = 0
        for i in range(0, newchn):
            for j in range(0, dlev):
                for k in range(0, dlev):
                    if sub2chan[i][j][k] == subch:
                        aux = i + 1
                        break
        return aux

    # new channel data

    new_an_pw = np.zeros((fa_types, newchn_side, newchn_side, 2), dtype=np.float64)
    new_sizes = np.zeros(newchn_side, dtype=np.float64)
    new_sizes[1] = free_sp + (dlev - 1) * pp
    new_sizes[-1] = free_sp + (dlev - 1) * pp
    new_gapsX_gap = np.zeros((fa_types, newchn_side, newchn_side - 1), dtype=np.float64)
    new_gapsY_gap = np.zeros((fa_types, newchn_side - 1, newchn_side), dtype=np.float64)

    for i in range(1, newchn_side - 1):
        new_sizes[i] = dlev * pp

    for n in range(0, fa_types):
        pw = np.zeros((nchn_side, nchn_side), dtype=np.float64)
        an = an_0
        for i in range(0, nrods_side):
            for j in range(0, nrods_side):
                for k in range(0, 2):
                    for l in range(0, 2):
                        an[subchannels_in_rod[i][j][k][l][0]][subchannels_in_rod[i][j][k][l][1]] -= math.pi / 4 * \
                                                                                                    (od_rods[n][i][j] ** 2) * 0.25
                        pw[subchannels_in_rod[i][j][k][l][0]][subchannels_in_rod[i][j][k][l][1]] += math.pi * \
                                                                                                    od_rods[n][i][j] * 0.25

        for i in range(0, newchn_side):
            for j in range(0, newchn_side):
                aux1 = 0
                aux2 = 0
                for k in range(0, dlev):
                    for l in range(0,  dlev):
                        aux1 += an[int(subchannels_in_channel[i][j][k][l][0])][int(subchannels_in_channel[i][j][k][l][1])]
                        aux2 += pw[int(subchannels_in_channel[i][j][k][l][0])][int(subchannels_in_channel[i][j][k][l][1])]

                new_an_pw[n][i][j][0] = aux1
                new_an_pw[n][i][j][1] = aux2

    rod = np.zeros(2, dtype=int)
    auxsubch = np.zeros(2, dtype=int)
    for n in range(0, fa_types):
        for i in range(0, newchn_side):
            for j in range(0, newchn_side):
                if i != newchn_side - 1:
                    if j != newchn_side - 1:
                        new_gapsX_gap[n][i][j] = new_sizes[i]
                        new_gapsY_gap[n][i][j] = new_sizes[j]
                        for k in range(0, dlev):
                            for l in range(0, 2):
                                auxsubch = [subchannels_in_channel[i][j][k][dlev - 1][0], subchannels_in_channel[i][j][k][dlev - 1][1]]
                                print(auxsubch)
                                rod[0] = rods_for_subchannel[auxsubch[0], auxsubch[1]]
                                if rod[0] != -1:
                                    rod[1] = rods_for_subchannel[subchannels_in_channel[i][j][k][dlev - 1][1]]
                                    new_gapsX_gap[n][i][j] -= 0.5* od_rods[n][rod[0]][rod[1]]

                                rod[0] = rods_for_subchannel[subchannels_in_channel[i][j][dlev - 1][k][0]]
                                if rod[0] != -1:
                                    rod[1] = rods_for_subchannel[subchannels_in_channel[i][j][dlev - 1][k][1]]
                                    new_gapsY_gap[n][i][j] -= 0.5 * od_rods[n][rod[0]][rod[1]]

                    else:
                        new_gapsY_gap[n][i][j] = new_sizes[j]
                        for k in range(0, dlev):
                            rod[0] = rods_for_subchannel[subchannels_in_channel[i][j][dlev - 1][k][0]]
                            if rod[0] != -1:
                                rod[1] = rods_for_subchannel[subchannels_in_channel[i][j][dlev - 1][k][1]]
                                new_gapsY_gap[n][i][j] -= 0.5 * od_rods[n][rod[0]][rod[1]]
                else:
                    new_gapsX_gap[n][i][j] = new_sizes[i]
                    for k in range(0, dlev):
                        rod[0] = rods_for_subchannel[subchannels_in_channel[i][j][k][dlev - 1][0]]
                        if rod[0] != -1:
                            rod[1] = rods_for_subchannel[subchannels_in_channel[i][j][k][dlev - 1][1]]
                            new_gapsX_gap[n][i][j] -= 0.5 * od_rods[n][rod[0]][rod[1]]











    # gets NK - the number of gaps - from Card 3.1. Calculates the new number of gaps

    ngaps_tot = int(lines[findheaderinline(lines, "NK NDM2 NDM3") + 1].split()[0])
    newngaps_tot = num_sides_connect * newchn_side + inner_gaps_in_fa * fa_num
    short_gap = card2_YSIZ[newchn_side - 1]#free_sp + (dlev - 1) * pp card # dimensions for the long and short gap between assemblies
    long_gap = card2_YSIZ[2*newchn_side - 1]

    # Creates gap data. First it creates gap data for a single assembly (in the future, for every type of assembly)

    def findthechannelingaps(vgaps, val, time=1):
        # finds the first channel with number of channel val in the vector of gaps and returns the number of gap
        aux = 0
        clock = 1
        for i in range(0, old_gaps_in_fa):
            if vgaps[i][0] == val:
                if clock < time:
                    clock = clock +1
                else:
                    aux = i+1
                    break
        return aux


    rod1 = int(0)
    rod2 = int(0)
    d1 = float(0)
    d2 = float(0)
    oldgap_type = []  # its final size should old_gaps_in_fa
    old_gap_connects = np.zeros((old_gaps_in_fa, 2), dtype=int)
    old_gap_gap = np.zeros(old_gaps_in_fa, dtype=np.float64)
    new_gap_connect = np.zeros((inner_gaps_in_fa, 2), dtype=int)
    new_gap_gaps = np.zeros(inner_gaps_in_fa, dtype=np.float64)
    new_loc_gaps = np.zeros((inner_gaps_in_fa, 2), dtype=np.float64)
    new_gap_lngts = np.zeros(inner_gaps_in_fa, dtype=np.float64)
    new_gap_dirs = []
    tot_gap_connect = np.zeros((newngaps_tot, 2), dtype=int)
    tot_gap_gaps =  np.zeros(newngaps_tot, dtype=np.float64)
    tot_loc_gaps = np.zeros((newngaps_tot, 2), dtype=np.float64)
    tot_gap_lngts = np.zeros(newngaps_tot, dtype=np.float64)
    tot_gap_dirs = []

    nrep = 2 * nchn_side - 1

    for i in range(0, old_gaps_in_fa):
        if i <= old_gaps_in_fa - nchn_side:
            if (i + 1) % nrep == 0:
                oldgap_type.append('y')
                old_gap_connects[i][0] = nchn_side*((i+1) // nrep)
                old_gap_connects[i][1] = old_gap_connects[i][0] + nchn_side
                old_gap_gap[i] = free_sp
                rod1 = rods_for_subchannel[old_gap_connects[i][0] - 1][1][0]
                old_gap_gap[i] -= 0.5 * od_rods[rod1 - 1]

            else:
                if ((i+1) % nrep) % 2 == 1:
                    oldgap_type.append('x')
                    old_gap_connects[i][0] = ((i+1) // nrep) * nchn_side + (((i+1) % nrep) // 2) + 1
                    old_gap_connects[i][1] = old_gap_connects[i][0] + 1
                    if i + 1 <= nrep:
                        old_gap_gap[i] = free_sp
                        rod1 = rods_for_subchannel[old_gap_connects[i][0] - 1][1][1]
                        old_gap_gap[i] -= 0.5 * od_rods[rod1 - 1]
                    else:
                        old_gap_gap[i] = pp
                        rod1 = rods_for_subchannel[old_gap_connects[i][0] - 1][0][1]
                        rod2 = rods_for_subchannel[old_gap_connects[i][0] - 1][1][1]
                        old_gap_gap[i] -= 0.5 * (od_rods[rod1 - 1] + od_rods[rod2 - 1])

                else:
                    oldgap_type.append('y')
                    old_gap_connects[i][0] = ((i + 1) // nrep) * nchn_side + (((i + 1) % nrep) // 2)
                    old_gap_connects[i][1] = old_gap_connects[i][0] + nchn_side
                    if (i + 1) % nrep == 2:
                        old_gap_gap[i] = free_sp
                        rod1 = rods_for_subchannel[old_gap_connects[i][0] - 1][1][1]
                        old_gap_gap[i] -= 0.5 * od_rods[rod1 - 1]
                    else:
                        old_gap_gap[i] = pp
                        rod1 = rods_for_subchannel[old_gap_connects[i][0] - 1][1][0]
                        rod2 = rods_for_subchannel[old_gap_connects[i][0] - 1][1][1]
                        old_gap_gap[i] -= 0.5 * (od_rods[rod1 - 1] + od_rods[rod2 - 1])

        else:
            oldgap_type.append('x')
            old_gap_connects[i][0] = (nchn_side-1) * nchn_side + ((i + 1) % nrep)
            old_gap_connects[i][1] = old_gap_connects[i][0] + 1
            old_gap_gap[i] = free_sp
            rod1 = rods_for_subchannel[old_gap_connects[i][0] - 1][0][1]
            old_gap_gap[i] -= 0.5 * od_rods[rod1 - 1]

    nrep = 2 * newchn_side - 1


    aux = int(0)
    nrep = 2 * newchn_side - 1
    totgaps_per_row = np.zeros(totrodsrow_n, dtype=int)
    acum_gaps_per_row = np.zeros(totrodsrow_n, dtype=int)
    for i in range(0, totrodsrow_n):
        aux = i // newchn_side + 1
        if i % newchn_side == newchn_side - 1:
            totgaps_per_row[i] = (newchn_side - 1) * assemb_in_row[aux - 1]\
                                 + connect_in_row[aux - 1][1] * newchn_side\
                                 + connect_in_row[aux - 1][0]

        else:
            totgaps_per_row[i] = nrep * assemb_in_row[aux - 1]\
                                 + connect_in_row[aux - 1][0]

    for i in range(0, totrodsrow_n):
        if i == 0:
            acum_gaps_per_row[i] = totgaps_per_row[i]

        else:
            acum_gaps_per_row[i] = acum_gaps_per_row[i - 1] + totgaps_per_row[i]

    auxrow = int(0)
    nrep_max = 2 * totrodscol_n - 1
    nrep = 2 * newchn_side - 1
    nrep1 = newchn_side - 1
    tot_gaps_guide = np.zeros((totrodsrow_n, nrep_max), dtype=int)
    aux = int(0)
    for i in range(0, totrodsrow_n):
        aux = 0
        auxrow = (i // newchn_side) + 1
        if i + 1 <= totrodsrow_n - 1:
            if (i + 1) % newchn_side != 0:
                for j in range(0, fa_numcol):
                    if j != fa_numcol - 1:
                        if core_map[auxrow - 1][j] != 0:
                            for k in range(0, nrep):
                                tot_gaps_guide[i][aux + k] = 1
                                # if i == 4:
                                #     print(tot_gaps_guide[i][aux + k])
                            if core_map[auxrow - 1][j + 1] != 0:
                                tot_gaps_guide[i][aux + nrep - 1] = -1
                                tot_gaps_guide[i][aux + nrep] = 1
                                aux += nrep + 1

                            else:
                                aux += nrep

                    else:
                        if core_map[auxrow - 1][j] != 0:
                            for k in range(0, nrep):
                                tot_gaps_guide[i][aux + k] = 1


            else:
                for j in range(0, fa_numcol):
                    if j != fa_numcol - 1:
                        if core_map[auxrow - 1][j] != 0:
                            if core_map[auxrow][j] != 0:
                                for k in range(0, nrep):
                                    if k == nrep - 1:
                                        tot_gaps_guide[i][aux + k] = -1
                                    else:
                                        if k + 1 % 2 == 1:
                                            tot_gaps_guide[i][aux + k] = 1
                                        else:
                                            tot_gaps_guide[i][aux + k] = -1

                                if core_map[auxrow - 1][j + 1] != 0:
                                    tot_gaps_guide[i][aux + nrep] = -1
                                    aux += nrep + 1
                                else:
                                    aux += nrep

                            else:
                                for k in range(0, nrep1):
                                    tot_gaps_guide[i][aux + k] = 1

                                if core_map[auxrow - 1][j + 1] != 0:
                                    tot_gaps_guide[i][aux + nrep1] = -1
                                    aux += nrep1 + 1
                                else:
                                    aux += nrep1

                    else:
                        if core_map[auxrow - 1][j] != 0:
                            if core_map[auxrow][j] != 0:
                                for k in range(0, nrep):
                                    if k == nrep - 1:
                                        tot_gaps_guide[i][aux + k] = -1
                                    else:
                                        if k + 1 % 2 == 1:
                                            tot_gaps_guide[i][aux + k] = 1
                                        else:
                                            tot_gaps_guide[i][aux + k] = -1

                                aux += nrep

                            else:
                                for k in range(0, nrep1):
                                    tot_gaps_guide[i][aux + k] = 1

                                aux += nrep1

        else:
            for j in range(0, fa_numcol):
                if core_map[auxrow - 1][j] != 0:
                    if j != fa_numcol - 1:
                        for k in range(0, nrep1):
                            tot_gaps_guide[i][aux + k] = 1

                        if core_map[auxrow - 1][j + 1] != 0:
                            tot_gaps_guide[i][aux + nrep1] = 1
                            aux += nrep1 + 1

                        else:
                            aux += nrep1

                    else:
                        for k in range(0, nrep1):
                            tot_gaps_guide[i][aux + k] = 1


    nono = int(lines[findheaderinline(lines, "NCHN NONO")+1].split()[2])
    new_msim = nono*newchn_tot

    # Reads NCD in Card 7.1, gets the different CDL and J positions from Card 7.2

    ncd = int(lines[findheaderinline(lines, "NCD NGT") + 1].split()[0])
    ngrids = int(ncd / ((nchn_tot + 1) // 12))
    grid_cdl = np.zeros((ngrids, 1), dtype=float)
    grid_j = np.zeros((ngrids, 1), dtype=int)
    new_ncd = ngrids * (((newchn_tot - 1) // 12) + 1)

    # gets the name of the .hdf5 and .vtk files from Card 17.1

    line_aux = lines[findheaderinline(lines, "HDF5_NAME VTK_NAME") + 1].split()
    namehdf5 = line_aux[0].split('.')[0]
    namevtk = line_aux[1].split('.')[0]

    # gets a map of the full core from card 17.2

    newrodsmap = np.zeros((totrodsrow_n, totrodscol_n), dtype=int)
    for i in range(0, totrodsrow_n):
        line_aux = lines[findheaderinline(lines, "Assembly Map") + 1 + (i // newchn_side)].split()
        for j in range(0, totrodscol_n):
            newrodsmap[i][j] = int(line_aux[j // newchn_side])

    # ------------------------WRITING--------------------------------------------------- #

    # Substitutes the number of channels in Group 2

    line_aux = lines[findheaderinline(lines, "NCH NDM2") + 1].split()
    line_aux[0] = str(newchn_tot)
    line_aux = '     ' + '    '.join(line_aux) + '\n'  # creates a sole string with the appropriate format
    lines[findheaderinline(lines, "NCH NDM2") + 1] = line_aux  # stores the modified line into its position

    # Deletes the excess of lines in Card 2.2

    removeexcesslines(lines, findheaderinline(lines, "I AN PW", time=1), nchn, newchn_tot)

    # Edits Card 2.2 lines

    for i in range(0, newchn_tot):
        line_aux = lines[findheaderinline(lines, "I AN PW", time=1) + 1 + i].split()
        line_aux[0] = str(i + 1)
        line_aux[1] = format_e(card2_an[i])
        line_aux[2] = format_e(card2_pw[i])
        line_aux[6] = format_e(card2_X[i])
        line_aux[7] = format_e(card2_Y[i])
        line_aux[8] = format_e(card2_XSIZ[i])
        line_aux[9] = format_e(card2_YSIZ[i])
        line_aux = '     ' + '   '.join(line_aux) + '\n'
        lines[findheaderinline(lines, "I AN PW", time=1) + 1 + i] = line_aux

    # Changes the number of gaps in Card 3.1

    line_aux = lines[findheaderinline(lines, "NK NDM2") + 1].split()
    line_aux[0] = str(newngaps_tot)
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "NK NDM2") + 1] = line_aux

    # Deletes excess of gaps in Card 3.3

    removeexcesslines(lines, findheaderinline(lines, "K IK JK", time=1), 2+2*ngaps_tot, 2+2*newngaps_tot)

    # Deletes excess of gaps in Card 3.3.5

    removeexcesslines(lines, findheaderinline(lines, "K X Y NORM", time=1), ngaps_tot, newngaps_tot)

    # Changes NCHN in Card 4.2

    line_aux = lines[findheaderinline(lines, "ISEC    NCHN  NONO") + 1].split()
    line_aux[1] = str(newchn_tot)
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "ISEC    NCHN  NONO") + 1] = line_aux

    # Deletes excess lines in Card 4.4

    removeexcesslines(lines, findheaderinline(lines, "KCHA KCHA", time=1), nchn_tot, newchn_tot)

    # Changes IWDE in Card 4.5

    line_aux = lines[findheaderinline(lines, "IWDE") + 1].split()
    line_aux[0] = str(newchn_tot)
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "IWDE") + 1] = line_aux

    # Changes MSIM in Card 4.6

    line_aux = lines[findheaderinline(lines, "MSIM") + 1].split()
    line_aux[0] = str(new_msim)
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "MSIM") + 1] = line_aux

    # Substitutes NCD in Card 7.1. Creates the new values to store in Card 7.2

    line_aux = lines[findheaderinline(lines, "NCD NGT") + 1].split()
    line_aux[0] = str(new_ncd)
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "NCD NGT") + 1] = line_aux
    clock = int(0)

    for i in range(0, ncd):
        if i == 0:
            grid_cdl[0] = float(lines[findheaderinline(lines, "CDL J") + 1].split()[0])
            grid_j[0] = int(lines[findheaderinline(lines, "CDL J") + 1].split()[1])

        else:
            if int(lines[findheaderinline(lines, "CDL J") + 1 + i].split()[1]) != grid_j[clock] and clock < ngrids - 1:
                grid_cdl[clock + 1] = float(lines[findheaderinline(lines, "CDL J") + 1 + i].split()[0])
                grid_j[clock + 1] = int(lines[findheaderinline(lines, "CDL J") + 1 + i].split()[1])
                clock = clock + 1

    # Removes excessive lines in Card 7.2

    removeexcesslines(lines, findheaderinline(lines, "CDL J CD1", time=1), ncd, new_ncd)

    # Gives new values in Card 7.2 and re-writes it

    lines_per_grid = int(new_ncd / ngrids)
    for i in range(0, new_ncd):
        line_aux = lines[findheaderinline(lines, "CDL J CD1", time=1) + 1 + i].split()
        line_aux[0] = str(float(grid_cdl[i // lines_per_grid]))
        line_aux[1] = str(int(grid_j[i // lines_per_grid]))
        line_aux[2] = str(12 * (i % lines_per_grid) + 1)
        line_aux[3] = str(12 * (i % lines_per_grid) + 2)
        line_aux[4] = str(12 * (i % lines_per_grid) + 3)
        line_aux[5] = str(12 * (i % lines_per_grid) + 4)
        line_aux[6] = str(12 * (i % lines_per_grid) + 5)
        line_aux[7] = str(12 * (i % lines_per_grid) + 6)
        line_aux[8] = str(12 * (i % lines_per_grid) + 7)
        line_aux[9] = str(12 * (i % lines_per_grid) + 8)
        line_aux[10] = str(12 * (i % lines_per_grid) + 9)
        line_aux[11] = str(12 * (i % lines_per_grid) + 10)
        line_aux[12] = str(12 * (i % lines_per_grid) + 11)
        line_aux[13] = str(12 * (i % lines_per_grid) + 12)
        if newchn_tot % 12 != 0:
            if (i + 1) % lines_per_grid == 0:
                for j in range(0, 12 - (newchn_tot % 12)):
                    line_aux[-1 - j] = str(0)
        line_aux = '     ' + '    '.join(line_aux) + '\n'
        lines[findheaderinline(lines, "CDL J CD1", time=1) + 1 + i] = line_aux

    # Changes NRRD in Card 8.1

    line_aux = lines[findheaderinline(lines, "NRRD NSRD", time=1) + 1].split()
    line_aux[0] = str(newnrod_tot)
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "NRRD NSRD", time=1) + 1] = line_aux

    # Changes NRT1 in Card 8.6

    line_aux = lines[findheaderinline(lines, "NRT1 NST1", time=1) + 1].split()
    line_aux[1] = str(newnrod_tot)
    line_aux = '     ' + '    '.join(line_aux) + '\n'  # creates a sole string with the appropriate format
    lines[findheaderinline(lines, "NRT1 NST1", time=1) + 1] = line_aux  # stores the modified line into its position

    # Deletes excess of lines in Card 8.7

    removeexcesslines(lines, findheaderinline(lines, "IRTB1 IRTB2"), ((nrods - 1) // 12) + 1,
                      ((newnrod_tot - 1) // 12) + 1)
    if newnrod_tot % 12 != 0:
        line_aux = lines[findheaderinline(lines, "IRTB1 IRTB2", time=1) + ((newnrod_tot - 1) // 12) + 1].split()
        for i in range(0, 12 - (newnrod_tot % 12)):
            line_aux[-i - 1] = "  "

        line_aux = '     ' + '     '.join(line_aux) + '\n'  # creates a sole string with the appropriate format
        lines[findheaderinline(lines, "IRTB1 IRTB2", time=1) + ((newnrod_tot - 1) // 12) + 1] = line_aux

    # Deletes Card 9.6 and 9.7

    if ngt > 0:
        start = findheaderinline(lines, "Card 9.6")-1
        n_oldlines = findnextto(lines, "Card 9.6", "********") - start - 1
        removeexcesslines(lines, start, n_oldlines, 0)

    # Changes NMAT in Card 10.1

    if ngt > 0:
        line_aux = lines[findheaderinline(lines, "NMAT NDM2", time=1) + 1].split()
        line_aux[0] = "1"
        line_aux = '     ' + '    '.join(line_aux) + '\n'
        lines[findheaderinline(lines, "NMAT NDM2", time=1) + 1] = line_aux

    # Changes NAXP in Card 11.1

    line_aux = lines[findheaderinline(lines, "NQA NAXP MNXN", time=1) + 1].split()
    line_aux[1] = str(1)
    line_aux = '     ' + '   '.join(line_aux) + '\n'  # creates a sole string with the appropriate format
    lines[findheaderinline(lines, "NQA NAXP MNXN",
                           time=1) + 1] = line_aux  # stores the modified line into its position

    # Deletes second axial profile (repeated Cards 11.3 and 11.4, that is included when there exist guide tubes.
    # In future versions this could be linked to the number of axial profiles left.

    if ngt > 0:
        deletebetweencards(lines, "Card 11.3", "Card 11.7", 2)

    # Changes number of boundary conditions in Card 13.1

    line_aux = lines[findheaderinline(lines, "NBND NKBD NFUN", time=1) + 1].split()
    line_aux[0] = str(2*newchn_tot)
    line_aux = '     ' + '   '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "NBND NKBD NFUN", time=1) + 1] = line_aux

    # deletes excess of boundary conditions in card 13.4

    removeexcesslines(lines, findheaderinline(lines, "IBD1 IBD2", time=1), nchn_tot, newchn_tot)
    removeexcesslines(lines, findheaderinline(lines, "outlet b.c.", time=1), nchn_tot, newchn_tot)

    # Changes names of the .hdf5 and .vtk files in Card 17.1
    
    line_aux = [namehdf5 + '_dlev' + str(dlev) + '.hdf5', namevtk + '_dlev' + str(dlev) + '.vtk']
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "HDF5_NAME VTK_NAME") + 1] = line_aux
    
    # Changes the rod map dimensions in Card 17.2

    line_aux = lines[findheaderinline(lines, "TOTRODSROW TOTRODSCOL", time=1) + 1].split()
    line_aux[0], line_aux[1] = str(totrodsrow_n), str(totrodscol_n)
    line_aux = '     ' + '   '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "TOTRODSROW TOTRODSCOL", time=1) + 1] = line_aux

    # Changes the channel map dimensions in Card 17.3

    line_aux = lines[findheaderinline(lines, "TOTCHANSROW TOTCHANSCOL", time=1) + 1].split()
    line_aux[0], line_aux[1] = str(totchansrow_n), str(totchanscol_n)
    line_aux = '     ' + '   '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "TOTCHANSROW TOTCHANSCOL", time=1) + 1] = line_aux

    # Deletes previous rod maps and channel maps

    removeexcesslines(lines, findcardinline(lines, "Card 17.4 - Rod Map"), totrodsrow_o, totrodsrow_n)
    removeexcesslines(lines, findcardinline(lines, "Card 17.4 - Channel Map"), totchansrow_o, totchansrow_n)

    for i in range(0, totrodsrow_n):
        line_aux = []
        for j in range(0, totrodscol_n):
            line_aux.append(str(newrodsmap[i][j]))

        line_aux = '     ' + '   '.join(line_aux) + '\n'
        lines[findheaderinline(lines, "Card 17.4 - Rod Map", time=1) + 1+i] = line_aux
        lines[findheaderinline(lines, "Card 17.4 - Channel Map", time=1) + 1 + i] = line_aux

    # TODO remake the new core map

    # ---------------------------------------END OF MAIN--------------------------------------------------

    file = open('new_deck.inp', 'w')
    file.writelines(lines)
    file.close()

    # TODO Assess that it is compatible with different assembly types and power profiles
    # TODO correct the alignment when writing lines (e.g. in channels or gaps cards) -> deck.inp file is more readable


main()


