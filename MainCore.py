import numpy as np
import sys
import math
import os
import argparse
'''
This Python script is aimed at processing an input file of CTF core simulation code, which has been generated by CTF preprocessor [1]. 
The input of this script will be a Core input file -i.e. more than one Fuel Assembly- The output of this file will be a  new CTF input file where previous subchannels
have been merged into larger ones. This code is not much pythonic, but that makes it easier to be read by a Matlab user. Many of the instructions assume
that there are no empty lines in the begginning of a Card, whereas most of them are ok with blank lines at the end of a Card.

(*)It is likely that the script will not work for core arrays with one row of fuel assemblies. If this is proven, a special
   case could be created, given that many processes in the new gaps building would simplify considerably
 
Author: Álvaro González Escapa
Institution: Technical University of Madrid
Python version: 3.8 


References:
[1]. Avramova, Maria N. and Salko, Robert (2016). CTF preprocessor's user manual. Pennsylvania State University. Reactor dynamics and fuel management group

'''


def findcardinline(doc, string, time=1):
    # so as to count the iterations. Caution is needed with the string here, because if one types
    # e.g. Card 3.3., it will find both Card 3.3 or Card 3.3.5.
    # With the variable time, it can now look for the n-th time that the Card appears (like in axial or radial profiles)
    cont = 0
    locus = -1
    clock = 1
    for linex in doc:

        # find returns the first position of the sequence that appears in the line. Should it not appear,
        # find returns -1. The exact value does not matter, only its presence

        if linex.find(string) >= 0:
            if clock < time:
                clock = clock + 1
                cont = cont + 1
            else:
                locus = cont
                break
        else:
            cont = cont + 1
    return locus


def findheaderinline(doc, string, time=1, separator=" "):
    cont = 0
    locus = -1
    clock = 1
    for linex in doc:
        if linex.replace(separator, "").find(string.replace(separator, "")) >= 0:
            if clock < time:
                clock = clock+1
                cont = cont + 1
            else:
                locus = cont
                break
        else:
            cont = cont + 1
    return locus


def findnextto(doc, string1, string2, time1=1, time2=1):
    start = int(findheaderinline(doc, string1, time=time1))
    aux_doc = [None]*(len(doc) - start)
    for i in range(0, len(doc) - start):
        aux_doc[i] = doc[i+start]

    finish = findheaderinline(aux_doc, string2, time=time2) + start
    return finish


# removeexcesslines takes a list of strings (the result of readlines method), sets an origin
# (ideally, a variables header) and from that, counts PRIOR lines -like the ones in Group 4 of deck.inp in CTF-
# in the new situation, ACTUAL lines must be conserved, from the position BEGIN, and thus REMOVE lines must be erased


def removeexcesslines(doc, begin, prior, actual):
    remove = prior - actual
    for i in range(0, remove):
        doc.pop(begin+actual+1)


def rewritesomelines(doc, begin, piece):
    # rewrites all the lines in piece. First one replaced is the next one to "begin"
    for i in range(0, len(piece)):
        doc[begin+1+i] = piece[i] + " \n"


# deletebetweencards looks for the position number time 1 of the Card 1 and deletes everything
# (including Card1) until it finds Card 2 (for the time2-th occasion)
def deletebetweencards(doc, card1, card2, time1=1, time2=1):
    pos1 = findcardinline(doc, card1, time1)
    pos2 = findcardinline(doc, card2, time2)
    for i in range(0, pos2 - pos1):
        doc.pop(pos1)


def chanindex_xy(x, y, numchannelside):
    # chanindex: from the x, y position (origin in bottom left corner), gets the index of the channel.
    # Numeration begins at top left and goes first rightwards and then downwards.
    # System of reference: x increases to the right, y increases from the bottom to the top
    return x+(numchannelside - y)*numchannelside


def retrieve_xy(index, numchannelside):
    # retrieve_xy: from the index and the number of channels per side, gets x and y (origin in bottom left corner). This
    # does not apply exclusively for subchannel, but for any homogenization
    y = numchannelside - (index - 1) // numchannelside
    x = index - (numchannelside - y)*numchannelside
    return [x, y]


def refchannel(numchannel, dlevel, n_sbchn_side):
    # f rom the number of a newly created channel (1,2,...N/Dlev**2), gets global index of its top left channel
    new_chn_per_side = n_sbchn_side / dlevel
    [x, y] = retrieve_xy(numchannel, new_chn_per_side)
    return 1 + (x-1) * dlevel + (new_chn_per_side - y) * n_sbchn_side * dlevel

def substitute(doc, string, new_data, pos_string, time=1, fwd=1):
    linaux = doc[findheaderinline(doc, string, time=time) + fwd].split()
    for i in range(0, len(new_data)):
        linaux[pos_string[i]] = str(new_data[i])

    linaux = linaux = '     ' + '   '.join(linaux) + '\n'
    doc[findheaderinline(doc, string, time=time) + fwd] = linaux

def format_e(n):    # This function allows to write a float as a string with scientific notation
    if abs(n) < 1e-5:
        return '0.00000E+00'
    else:
        a = '%E' % n
        return a.split('E')[0].rstrip('0').rstrip('.') + 'E' + a.split('E')[1]


def isit(a, b, prec=1e-4):
    if abs(a-b) < prec:
        return True
    else:
        return False


def ret_FA(numcols, numfa):
    '''
    This function returns the position of an FA in the core [x, y] given the number of FAs per column and the number of the FA in particular (starting from one)
    '''
    a = [int((numfa - 1) // numcols + 1), int(numfa - numcols*(((numfa - 1) // numcols + 1)-1))]
    return a

def main():
    '''
    Here the approach is that of deducting all the subchannel properties from prepro data, given that some features as
    the guide tubes location are more explicitly given in those files, rather than in deck.inp (the coordinates appear,
    whereas in deck.inp a search should be done in the radial power profile)
    '''
    # open the deck file and also the prepro files
    file = open("deck.inp", "r")
    lines = file.readlines()
    file.close()

    file_control = open("control.inp", "r")
    l_control = file_control.readlines()
    file_control.close()

    file_geo = open("geo.inp", "r")
    l_geo = file_geo.readlines()
    file_geo.close()

    file_assem = open("assem.inp", "r")
    l_assem = file_assem.readlines()
    file_assem.close()

    file_power = open("power.inp", "r")
    l_power = file_power.readlines()
    file_power.close()

    '''
    Begin the READS and simple Calculations, not DELETES nor WRITES yet
    '''

    # gets number of fuel assemblies in assem.inp
    fa_num = int(l_geo[findheaderinline(l_geo, "*Number of fuel assemblies")+1].split()[0])
    fa_types = int(l_geo[findheaderinline(l_geo, "NUMBER OF FUEL ASSEMBLY TYPES") + 1].split()[0])
    fa_numcol = int(l_geo[findheaderinline(l_geo, "CORE MESH X Y")+1].split()[0])
    fa_numrow = int(l_geo[findheaderinline(l_geo, "CORE MESH X Y")+1].split()[1])

    # gets rods number in the assembly

    nfrods = np.zeros(fa_types, dtype=int)
    nfrods[0] = int(l_assem[findheaderinline(l_assem, "Number of fuel rods")+1].split()[0])

    # gets number of guidetubes

    ngt = np.zeros(fa_types, dtype=int)
    ngt[0] = int(l_assem[findheaderinline(l_assem, "Number of guide tubes/water rods") + 1].split()[0])

    # gets the old number of channels in the deck.inp

    nchn_tot = int(lines[findheaderinline(lines, "NCH NDM2 NDM3")+1].split()[0])

    # total number of rods, rods per side, channels per side, discretization level

    nrods = nfrods[0] + ngt[0]          # so far, this figure will remain constant through the different FA's
    nrods_side = int(np.sqrt(nrods))
    nchn_side = nrods_side + 1
    nchn = nchn_side**2

    CONSOLE = False
    if CONSOLE == True:
        parser = argparse.ArgumentParser()
        parser.add_argument("-dlev", "--dlev", type=int)

        args = parser.parse_args()
        dlev = args.dlev

    else:
        dlev = 3

    indicradprof = 0

    if nchn_side % dlev != 0:
        print("ERROR: The original number of channels per side is not divisible by dlev: " + str(dlev) + "\n")
        sys.exit(1)

    # new number of channels in the new, homogenized bundle

    newchn = int(nchn/(dlev**2))
    newchn_side = int(nchn_side/dlev)
    newchn_tot = fa_num*newchn
    newnrod_tot = newchn_tot
    nrods_tot = fa_num * nrods

    inner_gaps_in_new_fa = 2 * newchn_side * (newchn_side - 1)

    # gets bundle pitch and converts it into m

    bp = float(l_assem[findheaderinline(l_assem, "Bundle pitch") + 1].split()[0])
    bp = bp / 1000

    # gets pin pitch and converts it into mm

    pp = float(l_assem[findheaderinline(l_assem, "Pin pitch") + 1].split()[0])
    pp = pp / 1000

    # defines useful magnitudes

    free_sp = (bp - (nrods_side - 1) * pp) / 2
    totrodsrow_n = fa_numrow * newchn_side
    totrodscol_n = fa_numcol * newchn_side
    totchansrow_n = totrodsrow_n
    totchanscol_n = totrodscol_n
    linaux = lines[findheaderinline(lines, "TOTRODSROW TOTRODSCOL") + 1].split()
    totrodsrow_o = int(linaux[0])
    linaux = lines[findheaderinline(lines, "TOTCHANSROW TOTCHANSCOL") + 1].split()
    totchansrow_o = int(linaux[0])
    totchansrow_s = fa_numrow * nchn_side
    totchanscol_s = fa_numcol * nchn_side

    fr_id = np.zeros(fa_types, dtype=float)
    fr_id[0] = float(l_assem[findheaderinline(l_assem, "Cladding inner diameter") + 1].split()[0])
    fr_id[0] = fr_id / 1000
    fr_od = np.zeros(fa_types, dtype=float)
    fr_od[0] = float(l_assem[findheaderinline(l_assem, "Cladding outer diameter") + 1].split()[0])
    fr_od[0] = fr_od / 1000
    fr_clad_mat = []
    fr_clad_mat.append(l_assem[findheaderinline(l_assem, "Cladding material") + 1].split()[0])
    gt_mat = []

    gapcond = np.zeros(fa_types, dtype=float)
    gapcond[0] = float(l_assem[findheaderinline(l_assem, "Constant gap conductance")+1].split()[0])
    gtpos = np.zeros((fa_types, nrods, 2), dtype=int)  # TODO Apparently it has no use
    ftds = np.zeros(fa_types, dtype=float)
    gt_id = np.zeros(fa_types, dtype=float)
    gt_od = np.zeros(fa_types, dtype=float)

    rodtype = np.zeros((fa_types, nrods_side, nrods_side), dtype=int)
    fp_diam = np.zeros(fa_types, dtype=float)

    fp_diam[0] = float(l_assem[findheaderinline(l_assem, "Fuel pellet diameter") + 1].split()[0])  # diam of fuel pellet
    fp_diam[0] = fp_diam[0] / 1000
    ftds[0] = float(l_assem[findheaderinline(l_assem, "Theoretical density of the fuel pellet") + 1].split()[0])

    if ngt[0] > 0:

        for i in range(ngt[0]):
            linaux = l_assem[findheaderinline(l_assem, "Use X Y format") + 1+i].split()
            gtpos[0][i][0] = int(linaux[0])
            gtpos[0][i][1] = int(linaux[1])
            rodtype[0][int(linaux[0]) - 1][int(linaux[1]) - 1] = 1

        gt_od[0] = float(l_assem[findheaderinline(l_assem, "Outer diameter of guide tube/water rod") + 1].split()[0])
        gt_od[0] = gt_od[0]/1000
        gt_id[0] = float(l_assem[findheaderinline(l_assem, "Inner diameter of guide tube/water rod") + 1].split()[0])
        gt_id[0] = gt_id[0] / 1000
        gt_mat.append(l_assem[findheaderinline(l_assem, "Guide tube/water rod material") + 1].split()[0])

    else:
        gt_mat.append("X")  # TODO should give it a thought

    if fa_types > 1:
        file_extra_fa = open("ExtraFA.inp", "r")
        l_extra_fa = file_extra_fa.readlines()
        file_extra_fa.close()
        for i in range(0, fa_types - 1):
            ngt[i + 1] = int(l_extra_fa[findheaderinline(l_extra_fa, "Number of guide tubes/water rods",
                                                         time=i+1) + 1].split()[0])
            ftds[i + 1] = float(l_extra_fa[findheaderinline(l_extra_fa, "Theoretical density of the fuel pellet",
                                                            time=i+1) + 1].split()[0])
            gapcond[i + 1] = float(l_extra_fa[findheaderinline(l_extra_fa, "Constant gap conductance",
                                                            time=i+1) + 1].split()[0])
            fr_clad_mat.append(l_extra_fa[findheaderinline(l_extra_fa, "Cladding material", time=i+1) + 1].split()[0])
            if ngt[i + 1] > 0:
                gt_id[i + 1] = float(l_extra_fa[findheaderinline(l_extra_fa,
                                                                 "Inner diameter of guide tube/water rod",
                                                                 time=i+1) + 1].split()[0])
                gt_od[i + 1] = float(l_extra_fa[findheaderinline(l_extra_fa,
                                                                 "Outer diameter of guide tube/water rod",
                                                                 time=i+1) + 1].split()[0])
                gt_mat.append(l_extra_fa[findheaderinline(l_extra_fa,
                                                          "Guide tube/water rod material",
                                                           time=i + 1) + 1].split()[0])
                for j in range(0, ngt[i + 1]):
                    linaux = l_extra_fa[findheaderinline(l_extra_fa, "Use X Y format",
                                                         time=i+1) + 1+j].split()
                    gtpos[i + 1][j][0] = int(linaux[0])
                    gtpos[i + 1][j][1] = int(linaux[1])
                    rodtype[i + 1][int(linaux[0]) - 1][int(linaux[1]) - 1] = 1

            else:
                gt_mat.append("X")

    fa_types_list = np.zeros(fa_num, dtype=int)

    # core map has the core map, with the positions and the indexes

    core_map = np.zeros((fa_numrow, fa_numcol), dtype=int)
    numb_core_map = np.zeros((fa_numrow, fa_numcol), dtype=int)
    core_centX = np.zeros(fa_numcol, dtype=np.float64)
    core_centY = np.zeros(fa_numrow, dtype=np.float64)

    for i in range(0, fa_numcol):
        core_centX[i] = ((i + 1) - 0.5 - float(fa_numcol) / 2) * bp

    for i in range(0, fa_numrow):
        core_centY[i] = ((i + 1) - 0.5 - float(fa_numrow) / 2) * bp

    core_centY = -1 * core_centY
    # TODO try with non-square core arrays

    # edit fa_transl, edit core_map

    cont_a = 1
    cont_b = 0
    for i in range(fa_numrow):
        linaux = (l_geo[findheaderinline(l_geo, "FUEL ASSEMBLY MAP") + 2+i].split())
        linaux2 = lines[findheaderinline(lines, "Assembly Map") + 1 + i].split()
        for j in range(fa_numcol):
            if int(linaux[j+1]) != 0:
                fa_types_list[cont_b] = int(linaux[j+1])
                cont_b = cont_b + 1

            core_map[i][j] = int(linaux[j+1])
            cont_a = cont_a + 1
            numb_core_map[i][j] = int(linaux2[j])

    # gets the number of connections between adjacent core maps

    fa_connections = int(0)
    for i in range(0, fa_numrow):
        for j in range(0, fa_numcol):
            if core_map[i][j] != 0:
                if i != fa_numrow - 1:
                    if j != fa_numcol - 1:
                        if core_map[i][j+1] != 0:
                            fa_connections += 1
                        if core_map[i+1][j] != 0:
                            fa_connections += 1

                    else:
                        if core_map[i+1][j] != 0:
                            fa_connections += 1

                else:
                    if j != fa_numcol - 1:
                        if core_map[i][j+1] != 0:
                            fa_connections += 1

    gap_betw_fa_tot = fa_connections * newchn_side
    newngaps_tot = gap_betw_fa_tot + fa_num * inner_gaps_in_new_fa

    # now, for every FA type, generic info about channels (An, Pw, XSIZ, YSIZ) should be created
    # creates an array to store the outer diameters of the rods

    od_s = np.zeros((fa_types, 2), dtype=float)
    od_s[0][0] = fr_od[0]

    if ngt[0] > 0:
        od_s[0][1] = gt_od[0]

    od_rods = np.ones((fa_types, nrods_side, nrods_side), dtype=float)

    for i in range(0, fa_types):
        od_s[i][0] = fr_od[i]
        if ngt[i] > 0:
            od_s[i][1] = gt_od[i]
        for j in range(0, nrods_side):
            for k in range(0, nrods_side):
                od_rods[i][j][k] = od_s[i][rodtype[i][j][k]]

    # creates an array with the subchannels that correspond to a rod

    subchannels_in_rod = np.zeros((nrods_side, nrods_side, 2, 2, 2), dtype=int)
    rods_for_subchannel = -1 * np.ones((nchn_side, nchn_side, 2, 2, 2), dtype=int)

    for i in range(0, nrods_side):
        for j in range(0, nrods_side):
            subchannels_in_rod[i][j][0][0] = [i, j]
            subchannels_in_rod[i][j][0][1] = [i, j + 1]
            subchannels_in_rod[i][j][1][0] = [i + 1, j]
            subchannels_in_rod[i][j][1][1] = [i + 1, j + 1]

    for i in range(0, nchn_side):
        for j in range(0, nchn_side):
            if i != 0:
                if i != nchn_side - 1:
                    if j != 0:
                        if j != nchn_side - 1:
                            rods_for_subchannel[i][j][0][0] = [i - 1, j - 1]
                            rods_for_subchannel[i][j][0][1] = [i - 1, j]
                            rods_for_subchannel[i][j][1][0] = [i, j - 1]
                            rods_for_subchannel[i][j][1][1] = [i, j]
                        else:
                            rods_for_subchannel[i][j][0][0] = [i - 1, j - 1]
                            rods_for_subchannel[i][j][1][0] = [i, j - 1]

                    else:
                        rods_for_subchannel[i][j][0][1] = [i - 1, j]
                        rods_for_subchannel[i][j][1][1] = [i, j]

                else:
                    if j != 0:
                        if j != nchn_side - 1:
                            rods_for_subchannel[i][j][0][0] = [i - 1, j - 1]
                            rods_for_subchannel[i][j][0][1] = [i - 1, j]

                        else:
                            rods_for_subchannel[i][j][0][0] = [i - 1, j - 1]

                    else:
                        rods_for_subchannel[i][j][0][1] = [i - 1, j]

            else:
                if j != 0:
                    if j != nchn_side - 1:
                        rods_for_subchannel[i][j][1][0] = [i, j - 1]
                        rods_for_subchannel[i][j][1][1] = [i, j]

                    else:
                        rods_for_subchannel[i][j][1][0] = [i, j - 1]

                else:
                    rods_for_subchannel[i][j][1][1] = [i, j]

    # creates a matrix to store the data of the subchannels, so they can be merged afterwards

    siz = np.zeros(nchn_side, dtype=np.float64)

    siz[0] = free_sp
    siz[-1] = free_sp

    for i in range(1, nchn_side - 1):
        siz[i] = pp

    # TODO ysiz and new_ysiz will be redundant as long as the FAs are squared arrays

    an = np.zeros((nchn_side, nchn_side), dtype=np.float64)
    an_0 = np.zeros((nchn_side, nchn_side), dtype=np.float64)
    gapsX_gap = np.zeros((fa_types, nchn_side, nchn_side - 1), dtype=np.float64)
    gapsY_gap = np.zeros((fa_types, nchn_side - 1, nchn_side), dtype=np.float64)

    for i in range(0, nchn_side):
        for j in range(0, nchn_side):
            an_0[i][j] = siz[j] * siz[i]

    pw = np.zeros((nchn_side, nchn_side), dtype=np.float64)

    # gives values to the subchannel data
    old_coordsX = np.zeros(nchn_side, dtype=np.float64)
    new_coordsX = np.zeros(newchn_side, dtype=np.float64)
    new_coordsX[0] = -bp / 2 + (free_sp + (dlev - 1) * pp) / 2
    new_coordsX[-1] = bp / 2 - (free_sp + (dlev - 1) * pp) / 2
    old_coordsX[0] = -bp / 2 + free_sp / 2
    old_coordsX[-1] = bp / 2 - free_sp / 2
    for i in range(1, newchn_side - 1):
        new_coordsX[i] = -bp / 2 + free_sp + (dlev - 1) * pp + dlev * pp / 2 + (i - 1) * dlev * pp

    for i in range(1, nchn_side - 1):
        old_coordsX[i] = -bp / 2 + free_sp + pp / 2 + pp * (i - 1)

    new_coordsY = -1 * new_coordsX
    old_coordsY = -1 * old_coordsX

    # edits nominal area and wet perimeter for the channels

    # creates an array that stores the number of subchannels that belong to the new channel
    subchannels_in_channel = np.zeros((newchn_side, newchn_side, dlev, dlev, 2), dtype=int)
    for i in range(0, nchn_side):
        for j in range(0, nchn_side):
            subchannels_in_channel[i // dlev][j // dlev][i % dlev][j % dlev] = [i, j]


    # new channel data

    new_an_pw = np.zeros((fa_types, newchn_side, newchn_side, 2), dtype=np.float64)
    new_sizes = np.zeros(newchn_side, dtype=np.float64)
    new_sizes[0] = free_sp + (dlev - 1) * pp
    new_sizes[-1] = free_sp + (dlev - 1) * pp
    new_gapsX_gap = np.zeros((fa_types, newchn_side, newchn_side - 1), dtype=np.float64)
    new_gapsY_gap = np.zeros((fa_types, newchn_side - 1, newchn_side), dtype=np.float64)

    for i in range(1, newchn_side - 1):
        new_sizes[i] = dlev * pp

    for n in range(0, fa_types):
        pw = np.zeros((nchn_side, nchn_side), dtype=np.float64)
        an = an_0
        for i in range(0, nrods_side):
            for j in range(0, nrods_side):
                for k in range(0, 2):
                    for l in range(0, 2):
                        an[subchannels_in_rod[i][j][k][l][0]][subchannels_in_rod[i][j][k][l][1]] -= math.pi / 4 * \
                                                                                                    (od_rods[n][i][j] ** 2) * 0.25
                        pw[subchannels_in_rod[i][j][k][l][0]][subchannels_in_rod[i][j][k][l][1]] += math.pi * \
                                                                                                    od_rods[n][i][j] * 0.25

        for i in range(0, newchn_side):
            for j in range(0, newchn_side):
                aux1 = 0
                aux2 = 0
                for k in range(0, dlev):
                    for l in range(0,  dlev):
                        aux1 += an[int(subchannels_in_channel[i][j][k][l][0])][int(subchannels_in_channel[i][j][k][l][1])]
                        aux2 += pw[int(subchannels_in_channel[i][j][k][l][0])][int(subchannels_in_channel[i][j][k][l][1])]

                new_an_pw[n][i][j][0] = aux1
                new_an_pw[n][i][j][1] = aux2

    rod = np.zeros((2, 2), dtype=int)
    auxsubch = np.zeros(2, dtype=int)
    for n in range(0, fa_types):
        for i in range(0, newchn_side):
            for j in range(0, newchn_side):
                if i != newchn_side - 1:
                    if j != newchn_side - 1:
                        new_gapsX_gap[n][i][j] = new_sizes[i]
                        new_gapsY_gap[n][i][j] = new_sizes[j]
                        for k in range(0, dlev):
                            auxsubch = [subchannels_in_channel[i][j][k][dlev - 1][0],
                                        subchannels_in_channel[i][j][k][dlev - 1][1]]

                            for l in range(0, 2):

                                rod[l][0] = rods_for_subchannel[auxsubch[0]][auxsubch[1]][l][1][0]
                                if rod[l][0] != -1:
                                    rod[l][1] = rods_for_subchannel[auxsubch[0]][auxsubch[1]][l][1][1]
                                    new_gapsX_gap[n][i][j] -= 0.5 * od_rods[n][rod[l][0]][rod[l][1]]

                            auxsubch = [subchannels_in_channel[i][j][dlev - 1][k][0],
                                        subchannels_in_channel[i][j][dlev - 1][k][1]]

                            for l in range(0, 2):

                                rod[l][0] = rods_for_subchannel[auxsubch[0]][auxsubch[1]][1][l][0]
                                if rod[l][0] != -1:
                                    rod[l][1] = rods_for_subchannel[auxsubch[0]][auxsubch[1]][1][l][1]
                                    new_gapsY_gap[n][i][j] -= 0.5 * od_rods[n][rod[l][0]][rod[l][1]]

                    else:
                        new_gapsY_gap[n][i][j] = new_sizes[j]
                        for k in range(0, dlev):
                            auxsubch = [subchannels_in_channel[i][j][dlev - 1][k][0],
                                        subchannels_in_channel[i][j][dlev - 1][k][1]]

                            for l in range(0, 2):

                                rod[l][0] = rods_for_subchannel[auxsubch[0]][auxsubch[1]][1][l][0]
                                if rod[l][0] != -1:
                                    rod[l][1] = rods_for_subchannel[auxsubch[0]][auxsubch[1]][1][l][1]
                                    new_gapsY_gap[n][i][j] -= 0.5 * od_rods[n][rod[l][0]][rod[l][1]]

                else:
                    if j != newchn_side - 1:
                        new_gapsX_gap[n][i][j] = new_sizes[i]
                        for k in range(0, dlev):
                            auxsubch = [subchannels_in_channel[i][j][k][dlev - 1][0],
                                        subchannels_in_channel[i][j][k][dlev - 1][1]]

                            for l in range(0, 2):

                                rod[l][0] = rods_for_subchannel[auxsubch[0]][auxsubch[1]][l][1][0]
                                if rod[l][0] != -1:
                                    rod[l][1] = rods_for_subchannel[auxsubch[0]][auxsubch[1]][l][1][1]
                                    new_gapsX_gap[n][i][j] -= 0.5 * od_rods[n][rod[l][0]][rod[l][1]]

    # gets NK - the number of gaps - from Card 3.1. Calculates the new number of gaps

    ngaps_tot = int(lines[findheaderinline(lines, "NK NDM2 NDM3") + 1].split()[0])

    nono = int(lines[findheaderinline(lines, "NCHN NONO")+1].split()[2])
    new_msim = nono*newchn_tot

    # Reads NCD in Card 7.1, gets the different CDL and J positions from Card 7.2

    ncd = int(lines[findheaderinline(lines, "NCD NGT") + 1].split()[0])
    ngrids = int(ncd / ((nchn_tot + 1) // 12))
    grid_cdl = np.zeros((ngrids, 1), dtype=float)
    grid_j = np.zeros((ngrids, 1), dtype=int)
    new_ncd = ngrids * (((newchn_tot - 1) // 12) + 1)

    # gets the name of the .hdf5 and .vtk files from Card 17.1

    line_aux = lines[findheaderinline(lines, "HDF5_NAME VTK_NAME") + 1].split()
    namehdf5 = line_aux[0].split('.')[0]
    namevtk = line_aux[1].split('.')[0]

    # gets a map of the full core from card 17.2

    newrodsmap = np.zeros((totrodsrow_n, totrodscol_n), dtype=int)
    new_chn_guide = np.zeros((totrodsrow_n, totrodscol_n), dtype=int)
    aux = int(0)
    for i in range(0, totrodsrow_n):
        line_aux = lines[findheaderinline(lines, "Assembly Map") + 1 + (i // newchn_side)].split()
        for j in range(0, totrodscol_n):
            auxfarow = i // newchn_side
            auxfacol = j // newchn_side
            newrodsmap[i][j] = int(line_aux[j // newchn_side])
            if core_map[auxfarow][auxfacol] != 0:
                aux += 1
                new_chn_guide[i][j] = aux

    # gets the radial power map from Card 11.8

    rad_pow_map = np.zeros((fa_num, nrods_side, nrods_side), dtype=np.float64)
    new_rad_pow_map = np.zeros((fa_num, newchn_side, newchn_side), dtype=np.float64)
    acum_nrods_inrow = np.zeros(totrodsrow_o, dtype=int)
    aux1 = int(0)
    for i in range(0, totrodsrow_o):
        aux = i // nrods_side
        for j in range(0, fa_numcol):
            if core_map[aux][j] != 0:
                aux1 += nrods_side

        acum_nrods_inrow[i] = aux1

    if nrods_tot % 8 == 0:
        aux = nrods_tot // 8
    else:
        aux = nrods_tot // 8 + 1

    aux1 = int(0)
    aux2 = int(0)
    aux3 = int(0)
    cont = int(0)
    auxrodrow = int(0)
    for i in range(0, aux):
        linaux = lines[findheaderinline(lines, "FQR1  FQR2") + 1 + i].split()
        if i != aux - 1:
            for j in range(0, 8):
                aux1 = i * 8 + j + 1

                if aux1 <= acum_nrods_inrow[0]:
                        auxrodrow = 0
                else:
                    for k in range(1, totrodsrow_o):
                        if aux1 > acum_nrods_inrow[k - 1] and aux1 <= acum_nrods_inrow[k]:
                            auxrodrow = k
                            aux1 -= acum_nrods_inrow[k - 1]

                auxfarow = auxrodrow // nrods_side
                aux2 = auxrodrow % nrods_side
                auxfacol = (aux1 - 1) // nrods_side + 1
                aux1 = (aux1 - 1) % nrods_side
                for l in range(0, fa_numcol):
                    if core_map[auxfarow][l] != 0:
                        cont += 1
                        if cont == auxfacol:
                            aux3 = numb_core_map[auxfarow][l]

                rad_pow_map[aux3 - 1][aux2][aux1] = np.float64(linaux[j])
                cont = 0

        else:
            if nrods_tot % 8 != 0:
                aux4 = nrods_tot % 8
            else:
                aux4 = 8
            for j in range(0, aux4):
                aux1 = i * 8 + j + 1
                if aux1 <= acum_nrods_inrow[0]:
                    auxrodrow = 0
                else:
                    for k in range(0, totrodsrow_o):
                        if aux1 > acum_nrods_inrow[k - 1] and aux1 <= acum_nrods_inrow[k]:
                            auxrodrow = k
                            aux1 -= acum_nrods_inrow[k - 1]

                auxfarow = auxrodrow // nrods_side
                aux2 = auxrodrow % nrods_side
                auxfaincol = (aux1 - 1) // nrods_side + 1
                aux1 = (aux1 - 1) % nrods_side
                for l in range(0, fa_numcol):
                    if core_map[auxfarow][l] != 0:
                        cont += 1
                        if cont == auxfaincol:
                            aux3 = numb_core_map[auxfarow][l]

                rad_pow_map[aux3 - 1][aux2][aux1] = np.float64(linaux[j])
                cont = 0

    if indicradprof != 0:
        file_extra_fa = open("ExtraFA.inp", "r")
        l_extra_fa = file_extra_fa.readlines()
        file_extra_fa.close()
        coreradprof = np.zeros(fa_num, dtype=float)
        for i in range(0, fa_numrow):
            linaux = l_extra_fa[findheaderinline(l_extra_fa, "Core radial power map") + 1 + i].split()
            for j in range(0, fa_numcol):
                if numb_core_map[i][j] != 0:
                    coreradprof[numb_core_map[i][j] - 1] = float(linaux[j])

        for j in range(0, fa_num):
            for k in range(0, nrods_side):
                for l in range(0, nrods_side):
                    linaux = l_extra_fa[findheaderinline(l_extra_fa, "FAPP Nº", time=1+j) + 1 + k].split()
                    rad_pow_map[j][k][l] = float(linaux[l]) * coreradprof[j][k][l]

    auxsubch = np.zeros(2, dtype=int)
    auxrod = np.zeros(2, dtype=int)
    for n in range(0, fa_num):
        for i in range(0, newchn_side):
            for j in range(0, newchn_side):
                for k in range(0, dlev):
                    for r in range(0, dlev):
                        auxsubch = [subchannels_in_channel[i][j][k][r][0], subchannels_in_channel[i][j][k][r][1]]
                        for p in range(0, 2):
                            for q in range(0, 2):
                                auxrod[0] = rods_for_subchannel[auxsubch[0]][auxsubch[1]][p][q][0]
                                if auxrod[0] != -1:
                                    auxrod[1] = rods_for_subchannel[auxsubch[0]][auxsubch[1]][p][q][1]
                                    new_rad_pow_map[n][i][j] += 0.25*rad_pow_map[n][auxrod[0]][auxrod[1]]

    # normalizes the radial profile

    new_rad_pow_map = np.true_divide(new_rad_pow_map, sum(sum(sum(new_rad_pow_map)))) * float(newchn_tot)
    rmults = np.zeros((newchn_side, newchn_side), dtype=float)
    for i in range(0, newchn_side):
        for j in range(0, newchn_side):
            if i != 0:
                if i != newchn_side-1:
                    if j != 0:
                        if j != newchn_side - 1:
                            rmults[i][j] = dlev**2

                        else:
                            rmults[i][j] = -0.5 * dlev + dlev**2

                    else:
                        rmults[i][j] = -0.5 * dlev + dlev ** 2

                else:
                    if j != 0:
                        if j != newchn_side - 1:
                            rmults[i][j] = -0.5 * dlev + dlev ** 2

                        else:
                            rmults[i][j] = 0.25 - dlev + dlev ** 2

                    else:
                        rmults[i][j] = 0.25 - dlev + dlev ** 2

            else:
                if j != 0:
                    if j != newchn_side - 1:
                        rmults[i][j] = -0.5 * dlev + dlev ** 2

                    else:
                        rmults[i][j] = 0.25 - dlev + dlev ** 2

                else:
                    rmults[i][j] = 0.25 - dlev + dlev ** 2

    # gets the old number of channels from Card 2.1
    tot_teor_chn = fa_num * nchn
    oldnchn = int(lines[findheaderinline(lines, "NCH NDM2") + 1].split()[0])

    # ------------------------------------------------------------------------------- #
    #                     MAPPING PREVIOUS CHANNELS  INTO NEW ONES                    #
    # ------------------------------------------------------------------------------- #
    # This part of the code would be straightforward should CTF prepro not merge channels in the boundary of FAs

    totsubchn_in_chn = np.zeros((totchansrow_s, totchanscol_s, 2), dtype=int)

    aux = int(0)
    found = int(0)
    teorcoord = np.zeros(2, dtype=float)
    for i in range(0, totchansrow_s):
        for j in range(0, totchanscol_s):
            auxfarow = i // nchn_side
            auxfacol = j // nchn_side
            auxnewrow = i // dlev
            auxnewcol = j // dlev
            rowinfa = i % nchn_side
            colinfa = j % nchn_side
            if core_map[auxfarow][auxfacol] != 0:
                teorcoord[0] = core_centX[auxfacol] + old_coordsX[colinfa]
                teorcoord[1] = core_centY[auxfarow] + old_coordsY[rowinfa]
                totsubchn_in_chn[i][j][0] = new_chn_guide[auxnewrow][auxnewcol]
                for k in range(0, oldnchn):
                    linaux = lines[findheaderinline(lines, "I AN PW") + 1 + k].split()
                    if (isit(teorcoord[0], float(linaux[6])) or isit(
                            teorcoord[0] - free_sp / 2, float(linaux[6])) or isit(
                            teorcoord[0] + free_sp / 2, float(linaux[6]))) and (isit(
                            teorcoord[1], float(linaux[7])) or isit(
                            teorcoord[1] - free_sp / 2, float(linaux[7])) or isit(
                            teorcoord[1] + free_sp / 2, float(linaux[7]))):

                        totsubchn_in_chn[i][j][1] = int(linaux[0])
                        break

    n_units = int(0)
    units_guide = np.zeros((totchansrow_n, totchanscol_n), dtype=int)
    for i in range(0, totchanscol_n):
        for j in range(0, totchanscol_n):
            auxfarow = i // newchn_side
            auxfacol = j // newchn_side
            rowinfa = i % newchn_side
            colinfa = j % newchn_side
            if core_map[auxfarow][auxfacol] != 0:
                if auxfarow != 0:
                    if auxfacol != 0:
                        if rowinfa != 0:
                            if rowinfa != newchn_side - 1:
                                if colinfa != 0:
                                    n_units += 1
                                    units_guide[i][j] = n_units
                                else:
                                    if core_map[auxfarow][auxfacol-1] == 0:
                                        n_units += 1
                                        units_guide[i][j] = n_units

                                    else:
                                        units_guide[i][j] = units_guide[i][j-1]

                            else:
                                if colinfa != 0:
                                    n_units += 1
                                    units_guide[i][j] = n_units
                                else:
                                    if core_map[auxfarow][auxfacol - 1] == 0:
                                        n_units += 1
                                        units_guide[i][j] = n_units
                                    else:
                                        units_guide[i][j] = units_guide[i][j - 1]


                        else:
                            if colinfa != 0:
                                if colinfa != newchn_side - 1:
                                    if core_map[auxfarow - 1][auxfacol] == 0:
                                        n_units += 1
                                        units_guide[i][j] = n_units
                                    else:
                                        units_guide[i][j] = units_guide[i-1][j]

                                else:
                                    if auxfacol != fa_numcol - 1:
                                        if core_map[auxfarow - 1][auxfacol] == 0 \
                                                and core_map[auxfarow - 1][auxfacol + 1] == 0:
                                            n_units += 1
                                            units_guide[i][j] = n_units

                                        else:
                                            if core_map[auxfarow - 1][auxfacol] != 0:
                                                units_guide[i][j] = units_guide[i - 1][j]

                                            if core_map[auxfarow - 1][auxfacol + 1] != 0:
                                                units_guide[i][j] = units_guide[i - 1][j+1]

                                    else:
                                        if core_map[auxfarow - 1][auxfacol] == 0:
                                            n_units += 1
                                            units_guide[i][j] = n_units

                                        else:
                                            units_guide[i][j] = units_guide[i - 1][j]

                            else:
                                if core_map[auxfarow - 1][auxfacol - 1] == 0 \
                                        and core_map[auxfarow - 1][auxfacol] == 0 \
                                        and core_map[auxfarow][auxfacol - 1] == 0:
                                    n_units += 1
                                    units_guide[i][j] = n_units

                                else:
                                    if core_map[auxfarow - 1][auxfacol - 1] != 0:
                                        units_guide[i][j] = units_guide[i - 1][j - 1]

                                    else:
                                        if core_map[auxfarow - 1][auxfacol] != 0:
                                            units_guide[i][j] = units_guide[i - 1][j]

                                        else:
                                            units_guide[i][j] = units_guide[i][j-1]


                    else:
                        if rowinfa != 0:
                            n_units += 1
                            units_guide[i][j] = n_units
                        else:
                            if colinfa != newchn_side - 1:
                                if core_map[auxfarow - 1][auxfacol] == 0:
                                    n_units += 1
                                    units_guide[i][j] = n_units

                                else:
                                    units_guide[i][j] = units_guide[i - 1][j]


                            else:
                                if core_map[auxfarow - 1][auxfacol] == 0 \
                                        and core_map[auxfarow - 1][auxfacol + 1] == 0:
                                    n_units += 1
                                    units_guide[i][j] = n_units

                                else:
                                    if core_map[auxfarow - 1][auxfacol] != 0:
                                        units_guide[i][j] = units_guide[i - 1][j]

                                    else:
                                        units_guide[i][j] = units_guide[i - 1][j + 1]


                else:
                    if auxfacol != 0:
                        if colinfa != 0:
                            n_units += 1
                            units_guide[i][j] = n_units

                        else:
                            if core_map[auxfarow][auxfacol - 1] == 0:
                                n_units += 1
                                units_guide[i][j] = n_units

                            else:
                                units_guide[i][j] = units_guide[i][j - 1]
                    else:
                        n_units += 1
                        units_guide[i][j] = n_units

    # ------------------------------------------------------------------------------- #
    #                            WRITING                                              #
    # ------------------------------------------------------------------------------- #

    # Substitutes the number of channels in Group 2

    substitute(lines, "NCH NDM2", [newchn_tot], [0], time=1, fwd=1)

    # Deletes the excess of lines in Card 2.2

    removeexcesslines(lines, findheaderinline(lines, "I AN PW", time=1), oldnchn, newchn_tot)

    # Changes the number of gaps in Card 3.1
    substitute(lines, "NK NDM2", [newngaps_tot], [0], time=1, fwd=1)
    # line_aux = lines[findheaderinline(lines, "NK NDM2") + 1].split()
    # line_aux[0] = str(newngaps_tot)
    # line_aux = '     ' + '    '.join(line_aux) + '\n'
    # lines[findheaderinline(lines, "NK NDM2") + 1] = line_aux

    # Deletes excess of gaps in Card 3.3

    removeexcesslines(lines, findheaderinline(lines, "K IK JK", time=1), 2+2*ngaps_tot, 2+2*newngaps_tot)

    # Deletes excess of gaps in Card 3.3.5

    removeexcesslines(lines, findheaderinline(lines, "K X Y NORM", time=1), ngaps_tot, newngaps_tot)

    # Changes NCHN in Card 4.2
    substitute(lines, "ISEC    NCHN  NONO", [newchn_tot], [1], time=1, fwd=1)

    # Deletes excess lines in Card 4.4

    removeexcesslines(lines, findheaderinline(lines, "KCHA KCHA", time=1), nchn_tot, newchn_tot)

    # Changes IWDE in Card 4.5
    substitute(lines, "IWDE", [newchn_tot], [0], time=1, fwd=1)

    # Changes MSIM in Card 4.6
    substitute(lines, "MSIM", [new_msim], [0], time=1, fwd=1)

    # Substitutes NCD in Card 7.1. Creates the new values to store in Card 7.2
    substitute(lines, "NCD NGT", [new_ncd], [0], time=1, fwd=1)

    clock = int(0)

    for i in range(0, ncd):
        if i == 0:
            grid_cdl[0] = float(lines[findheaderinline(lines, "CDL J") + 1].split()[0])
            grid_j[0] = int(lines[findheaderinline(lines, "CDL J") + 1].split()[1])

        else:
            if int(lines[findheaderinline(lines, "CDL J") + 1 + i].split()[1]) != grid_j[clock] and clock < ngrids - 1:
                grid_cdl[clock + 1] = float(lines[findheaderinline(lines, "CDL J") + 1 + i].split()[0])
                grid_j[clock + 1] = int(lines[findheaderinline(lines, "CDL J") + 1 + i].split()[1])
                clock = clock + 1

    # Removes excessive lines in Card 7.2

    removeexcesslines(lines, findheaderinline(lines, "CDL J CD1", time=1), ncd, new_ncd)

    # Gives new values in Card 7.2 and re-writes it

    lines_per_grid = int(new_ncd / ngrids)
    for i in range(0, new_ncd):
        line_aux = lines[findheaderinline(lines, "CDL J CD1", time=1) + 1 + i].split()
        line_aux[0] = str(float(grid_cdl[i // lines_per_grid]))
        line_aux[1] = str(int(grid_j[i // lines_per_grid]))
        line_aux[2] = str(12 * (i % lines_per_grid) + 1)
        line_aux[3] = str(12 * (i % lines_per_grid) + 2)
        line_aux[4] = str(12 * (i % lines_per_grid) + 3)
        line_aux[5] = str(12 * (i % lines_per_grid) + 4)
        line_aux[6] = str(12 * (i % lines_per_grid) + 5)
        line_aux[7] = str(12 * (i % lines_per_grid) + 6)
        line_aux[8] = str(12 * (i % lines_per_grid) + 7)
        line_aux[9] = str(12 * (i % lines_per_grid) + 8)
        line_aux[10] = str(12 * (i % lines_per_grid) + 9)
        line_aux[11] = str(12 * (i % lines_per_grid) + 10)
        line_aux[12] = str(12 * (i % lines_per_grid) + 11)
        line_aux[13] = str(12 * (i % lines_per_grid) + 12)
        if newchn_tot % 12 != 0:
            if (i + 1) % lines_per_grid == 0:
                for j in range(0, 12 - (newchn_tot % 12)):
                    line_aux[-1 - j] = str(0)
        line_aux = '     ' + '    '.join(line_aux) + '\n'
        lines[findheaderinline(lines, "CDL J CD1", time=1) + 1 + i] = line_aux

    # Changes NRRD in Card 8.1
    substitute(lines, "NRRD NSRD", [newnrod_tot], [0], time=1, fwd=1)
    # line_aux = lines[findheaderinline(lines, "NRRD NSRD", time=1) + 1].split()
    # line_aux[0] = str(newnrod_tot)
    # line_aux = '     ' + '    '.join(line_aux) + '\n'
    # lines[findheaderinline(lines, "NRRD NSRD", time=1) + 1] = line_aux

    # Removes excess of lines in Card 8.3

    removeexcesslines(lines, findheaderinline(lines, "NSCH PIE"), 2 * nrods_tot, 2 * newnrod_tot)

    # Changes NRT1 in Card 8.6
    substitute(lines, "NRT1 NST1", [newnrod_tot], [1], time=1, fwd=1)

    # Deletes excess of lines in Card 8.7

    removeexcesslines(lines, findheaderinline(lines, "IRTB1 IRTB2"), ((nrods - 1) // 12) + 1,
                      ((newnrod_tot - 1) // 12) + 1)
    if newnrod_tot % 12 != 0:
        line_aux = lines[findheaderinline(lines, "IRTB1 IRTB2", time=1) + ((newnrod_tot - 1) // 12) + 1].split()
        for i in range(0, 12 - (newnrod_tot % 12)):
            line_aux[-i - 1] = "  "

        line_aux = '     ' + '     '.join(line_aux) + '\n'
        lines[findheaderinline(lines, "IRTB1 IRTB2", time=1) + ((newnrod_tot - 1) // 12) + 1] = line_aux

    # Deletes excess lines in Card 8

    auxoldlines = nrods_tot // 8 + 1
    if auxoldlines % 8 == 0:
        auxoldlines = nrods_tot // 8

    auxnumlines = newnrod_tot // 8 + 1
    if newnrod_tot % 8 == 0:
        auxnumlines = newnrod_tot // 8
    else:
        aux = 8 - newnrod_tot % 8

    removeexcesslines(lines, findheaderinline(lines, "FQR1 FQR2", time=1), auxoldlines, auxnumlines)
    if newnrod_tot % 8 != 0:
        linaux = lines[findheaderinline(lines, "FQR1 FQR2") + auxnumlines].split()
        for i in range(0, aux):
            linaux[-(i + aux)] = " "

        linaux = '   ' + '   '.join(linaux) + '\n'
        lines[findheaderinline(lines, "FQR1 FQR2") + auxnumlines] = linaux

    # Writes Card 2 and Card 3 data

    contchan = int(0)
    contgap = int(0)
    for i in range(0, totrodsrow_n):
        for j in range(0, totrodscol_n):
            auxfarow = i // newchn_side
            auxfacol = j // newchn_side
            rowinfa = i % newchn_side
            colinfa = j % newchn_side
            if core_map[auxfarow][auxfacol] != 0:
                contchan += 1
                auxfatype = core_map[auxfarow][auxfacol]
                auxfanum = numb_core_map[auxfarow][auxfacol]
                linaux = lines[findheaderinline(lines, "I AN PW") + contchan].split()
                linaux[0] = str(contchan)
                linaux[1] = format_e(new_an_pw[auxfatype - 1][rowinfa][colinfa][0])
                linaux[2] = format_e(new_an_pw[auxfatype - 1][rowinfa][colinfa][1])
                linaux[6] = format_e(new_coordsX[colinfa] + core_centX[auxfacol])
                linaux[7] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow])
                linaux[8] = format_e(new_sizes[colinfa])
                linaux[9] = format_e(new_sizes[rowinfa])
                linaux = '   ' + '   '.join(linaux) + '\n'

                lines[findheaderinline(lines, "I AN PW") + contchan] = linaux

                linaux = lines[findheaderinline(lines, " N   IFTY   IAXP") + 3 + 2 * (contchan - 1)].split()
                linaux2 = lines[findheaderinline(lines, " N   IFTY   IAXP") + 2 + 2 * contchan].split()
                linaux[0] = str(contchan)

                linaux[5] = str(rmults[rowinfa][colinfa])
                linaux[6] = format_e(gapcond[auxfatype - 1])
                linaux2[0] = line_aux[0]
                linaux2[1] = '1.000'
                linaux2[2] = '0'
                linaux2[3] = '0.000'
                linaux2[4] = '0'
                linaux2[5] = '0.000'
                linaux2[6] = '0'
                linaux2[7] = '0.000'
                linaux2[8] = '0'
                linaux2[9] = '0.000'
                linaux2[10] = '0'
                linaux2[11] = '0.000'
                linaux2[12] = '0'
                linaux2[13] = '0.000'
                linaux2[14] = '0'
                linaux2[15] = '0.000'

                linaux = '     ' + '   '.join(linaux) + '\n'
                linaux2 = '     ' + '   '.join(linaux2) + '\n'

                lines[findheaderinline(lines, " N   IFTY   IAXP") + 3 + 2 * (contchan - 1)] = linaux
                lines[findheaderinline(lines, " N   IFTY   IAXP") + 2 + 2 * contchan] = linaux2

                auxlin = (contchan - 1) // 8 + 1
                auxcol = (contchan - 1) % 8
                linaux3 = lines[findheaderinline(lines, "FQR1 FQR2") + auxlin].split()
                linaux3[auxcol] = str(new_rad_pow_map[auxfanum - 1][rowinfa][colinfa])
                linaux3 = '   ' + '   '.join(linaux3) + '\n'
                lines[findheaderinline(lines, "FQR1") + auxlin] = linaux3

                if rowinfa != newchn_side - 1:
                    if colinfa != newchn_side - 1:
                        contgap += 1
                        linaux = lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                        linaux2 = lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                        linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                        linaux[0] = str(contgap)
                        linaux[1] = str(contchan)
                        linaux[2] = str(new_chn_guide[i][j + 1])
                        linaux[3] = format_e(new_gapsX_gap[auxfatype - 1][rowinfa][colinfa])
                        linaux[4] = format_e(new_coordsX[colinfa + 1] - new_coordsX[colinfa])

                        linaux2[0] = str(dlev)

                        linaux3[1] = format_e(new_coordsX[colinfa] + core_centX[auxfacol] + new_sizes[colinfa] / 2)
                        linaux3[2] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow])
                        linaux3[3] = 'x'

                        linaux = '   ' + '   '.join(linaux) + '\n'
                        linaux2 = '   ' + '   '.join(linaux2) + '\n'
                        linaux3 = '   ' + '   '.join(linaux3) + '\n'

                        lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                        lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                        lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                        contgap += 1
                        linaux = lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                        linaux2 = lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                        linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                        linaux[0] = str(contgap)
                        linaux[1] = str(contchan)
                        linaux[2] = str(new_chn_guide[i + 1][j])
                        linaux[3] = format_e(new_gapsY_gap[auxfatype - 1][rowinfa][colinfa])
                        linaux[4] = format_e(new_coordsY[rowinfa] - new_coordsY[rowinfa + 1])
                        linaux2[0] = str(dlev)

                        linaux3[1] = format_e(new_coordsX[colinfa] + core_centX[auxfacol])
                        linaux3[2] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow] - new_sizes[rowinfa] / 2)
                        linaux3[3] = 'y'

                        linaux = '   ' + '   '.join(linaux) + '\n'
                        linaux2 = '   ' + '   '.join(linaux2) + '\n'
                        linaux3 = '   ' + '   '.join(linaux3) + '\n'

                        lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                        lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                        lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                    else:
                        if auxfacol != fa_numcol - 1:
                            if core_map[auxfarow][auxfacol + 1] != 0:
                                # 2
                                contgap += 1
                                linaux = lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                                linaux2 = lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                                linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                                linaux[0] = str(contgap)
                                linaux[1] = str(contchan)
                                linaux[2] = str(new_chn_guide[i][j + 1])
                                linaux[3] = format_e(new_sizes[rowinfa])
                                linaux[4] = format_e(new_sizes[0])

                                linaux2[0] = str(dlev)

                                linaux3[1] = format_e(new_coordsX[colinfa] + core_centX[auxfacol] + new_sizes[colinfa] / 2)
                                linaux3[2] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow])
                                linaux3[3] = 'x'

                                linaux = '   ' + '   '.join(linaux) + '\n'
                                linaux2 = '   ' + '   '.join(linaux2) + '\n'
                                linaux3 = '   ' + '   '.join(linaux3) + '\n'

                                lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                                lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                                lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                                contgap += 1
                                linaux = lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                                linaux2 = lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                                linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                                linaux[0] = str(contgap)
                                linaux[1] = str(contchan)
                                linaux[2] = str(new_chn_guide[i + 1][j])
                                linaux[3] = format_e(new_gapsY_gap[auxfatype - 1][rowinfa][colinfa])
                                linaux[4] = format_e(new_coordsY[rowinfa] - new_coordsY[rowinfa + 1])
                                linaux2[0] = str(dlev)

                                linaux3[1] = format_e(new_coordsX[colinfa] + core_centX[auxfacol])
                                linaux3[2] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow] - new_sizes[rowinfa] / 2)
                                linaux3[3] = 'y'

                                linaux = '   ' + '   '.join(linaux) + '\n'
                                linaux2 = '   ' + '   '.join(linaux2) + '\n'
                                linaux3 = '   ' + '   '.join(linaux3) + '\n'

                                lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                                lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                                lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                            else:
                                # 3
                                contgap += 1
                                linaux = lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                                linaux2 = lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                                linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                                linaux[0] = str(contgap)
                                linaux[1] = str(contchan)
                                linaux[2] = str(new_chn_guide[i + 1][j])
                                linaux[3] = format_e(new_gapsY_gap[auxfatype - 1][rowinfa][colinfa])
                                linaux[4] = format_e(new_coordsY[rowinfa] - new_coordsY[rowinfa + 1])
                                linaux2[0] = str(dlev)

                                linaux3[1] = format_e(new_coordsX[colinfa] + core_centX[auxfacol])
                                linaux3[2] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow] - new_sizes[rowinfa] / 2)
                                linaux3[3] = 'y'

                                linaux = '   ' + '   '.join(linaux) + '\n'
                                linaux2 = '   ' + '   '.join(linaux2) + '\n'
                                linaux3 = '   ' + '   '.join(linaux3) + '\n'

                                lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                                lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                                lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                        else:
                            # 4
                            contgap += 1
                            linaux = lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                            linaux2 = lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                            linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                            linaux[0] = str(contgap)
                            linaux[1] = str(contchan)
                            linaux[2] = str(new_chn_guide[i + 1][j])
                            linaux[3] = format_e(new_gapsY_gap[auxfatype - 1][rowinfa][colinfa])
                            linaux[4] = format_e(new_coordsY[rowinfa] - new_coordsY[rowinfa + 1])
                            linaux2[0] = str(dlev)

                            linaux3[1] = format_e(new_coordsX[colinfa] + core_centX[auxfacol])
                            linaux3[2] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow] - new_sizes[rowinfa] / 2)
                            linaux3[3] = 'y'

                            linaux = '   ' + '   '.join(linaux) + '\n'
                            linaux2 = '   ' + '   '.join(linaux2) + '\n'
                            linaux3 = '   ' + '   '.join(linaux3) + '\n'

                            lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                            lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                            lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3


                else:
                    if colinfa != newchn_side - 1:
                        if auxfarow != fa_numrow - 1:
                            if core_map[auxfarow + 1][auxfacol] != 0:
                                # 5
                                contgap += 1
                                linaux = lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                                linaux2 = lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                                linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                                linaux[0] = str(contgap)
                                linaux[1] = str(contchan)
                                linaux[2] = str(new_chn_guide[i][j + 1])
                                linaux[3] = format_e(new_gapsX_gap[auxfatype - 1][rowinfa][colinfa])
                                linaux[4] = format_e(new_coordsX[colinfa + 1] - new_coordsX[colinfa])

                                linaux2[0] = str(dlev)

                                linaux3[1] = format_e(
                                    new_coordsX[colinfa] + core_centX[auxfacol] + new_sizes[colinfa] / 2)
                                linaux3[2] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow])
                                linaux3[3] = 'x'

                                linaux = '   ' + '   '.join(linaux) + '\n'
                                linaux2 = '   ' + '   '.join(linaux2) + '\n'
                                linaux3 = '   ' + '   '.join(linaux3) + '\n'

                                lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                                lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                                lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                                contgap += 1
                                linaux = lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                                linaux2 = lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                                linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                                linaux[0] = str(contgap)
                                linaux[1] = str(contchan)
                                linaux[2] = str(new_chn_guide[i + 1][j])
                                linaux[3] = format_e(new_sizes[colinfa])
                                linaux[4] = format_e(new_sizes[0])

                                linaux2[0] = str(dlev)

                                linaux3[1] = format_e(new_coordsX[colinfa] + core_centX[auxfacol])
                                linaux3[2] = format_e(
                                    new_coordsY[rowinfa] + core_centY[auxfarow] - new_sizes[rowinfa] / 2)
                                linaux3[3] = 'y'

                                linaux = '   ' + '   '.join(linaux) + '\n'
                                linaux2 = '   ' + '   '.join(linaux2) + '\n'
                                linaux3 = '   ' + '   '.join(linaux3) + '\n'

                                lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                                lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                                lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                            else:
                                # 6
                                contgap += 1
                                linaux = lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                                linaux2 = lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                                linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                                linaux[0] = str(contgap)
                                linaux[1] = str(contchan)
                                linaux[2] = str(new_chn_guide[i][j + 1])
                                linaux[3] = format_e(new_gapsX_gap[auxfatype - 1][rowinfa][colinfa])
                                linaux[4] = format_e(new_coordsX[colinfa + 1] - new_coordsX[colinfa])

                                linaux2[0] = str(dlev)

                                linaux3[1] = format_e(
                                    new_coordsX[colinfa] + core_centX[auxfacol] + new_sizes[colinfa] / 2)
                                linaux3[2] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow])
                                linaux3[3] = 'x'

                                linaux = '   ' + '   '.join(linaux) + '\n'
                                linaux2 = '   ' + '   '.join(linaux2) + '\n'
                                linaux3 = '   ' + '   '.join(linaux3) + '\n'

                                lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                                lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                                lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                        else:
                            # 7
                            contgap += 1
                            linaux = lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                            linaux2 = lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                            linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                            linaux[0] = str(contgap)
                            linaux[1] = str(contchan)
                            linaux[2] = str(new_chn_guide[i][j + 1])
                            linaux[3] = format_e(new_gapsX_gap[auxfatype - 1][rowinfa][colinfa])
                            linaux[4] = format_e(new_coordsX[colinfa + 1] - new_coordsX[colinfa])

                            linaux2[0] = str(dlev)

                            linaux3[1] = format_e(
                                new_coordsX[colinfa] + core_centX[auxfacol] + new_sizes[colinfa] / 2)
                            linaux3[2] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow])
                            linaux3[3] = 'x'

                            linaux = '   ' + '   '.join(linaux) + '\n'
                            linaux2 = '   ' + '   '.join(linaux2) + '\n'
                            linaux3 = '   ' + '   '.join(linaux3) + '\n'

                            lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                            lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                            lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                    else:
                        if auxfarow != fa_numrow - 1:
                            if auxfacol != fa_numcol - 1:
                                if core_map[auxfarow][auxfacol + 1] != 0:
                                    if core_map[auxfarow + 1][auxfacol] != 0:
                                        # 8
                                        contgap += 1
                                        linaux = lines[
                                            findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                                        linaux2 = lines[
                                            findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                                        linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                                        linaux[0] = str(contgap)
                                        linaux[1] = str(contchan)
                                        linaux[2] = str(new_chn_guide[i][j + 1])
                                        linaux[3] = format_e(new_sizes[rowinfa])
                                        linaux[4] = format_e(new_sizes[0])

                                        linaux2[0] = str(dlev)

                                        linaux3[1] = format_e(
                                            new_coordsX[colinfa] + core_centX[auxfacol] + new_sizes[colinfa] / 2)
                                        linaux3[2] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow])
                                        linaux3[3] = 'x'

                                        linaux = '   ' + '   '.join(linaux) + '\n'
                                        linaux2 = '   ' + '   '.join(linaux2) + '\n'
                                        linaux3 = '   ' + '   '.join(linaux3) + '\n'

                                        lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                                        lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                                        lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                                        contgap += 1

                                        linaux = lines[
                                            findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                                        linaux2 = lines[
                                            findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                                        linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                                        linaux[0] = str(contgap)
                                        linaux[1] = str(contchan)
                                        linaux[2] = str(new_chn_guide[i + 1][j])
                                        linaux[3] = format_e(new_sizes[colinfa])
                                        linaux[4] = format_e(new_sizes[0])

                                        linaux2[0] = str(dlev)

                                        linaux3[1] = format_e(new_coordsX[colinfa] + core_centX[auxfacol])
                                        linaux3[2] = format_e(
                                            new_coordsY[rowinfa] + core_centY[auxfarow] - new_sizes[rowinfa] / 2)
                                        linaux3[3] = 'y'

                                        linaux = '   ' + '   '.join(linaux) + '\n'
                                        linaux2 = '   ' + '   '.join(linaux2) + '\n'
                                        linaux3 = '   ' + '   '.join(linaux3) + '\n'

                                        lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                                        lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                                        lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                                    else:
                                        # 9
                                        contgap += 1
                                        linaux = lines[
                                            findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                                        linaux2 = lines[
                                            findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                                        linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                                        linaux[0] = str(contgap)
                                        linaux[1] = str(contchan)
                                        linaux[2] = str(new_chn_guide[i][j + 1])
                                        linaux[3] = format_e(new_sizes[colinfa])
                                        linaux[4] = format_e(new_sizes[0])

                                        linaux2[0] = str(dlev)

                                        linaux3[1] = format_e(
                                            new_coordsX[colinfa] + core_centX[auxfacol] + new_sizes[colinfa] / 2)
                                        linaux3[2] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow])
                                        linaux3[3] = 'x'

                                        linaux = '   ' + '   '.join(linaux) + '\n'
                                        linaux2 = '   ' + '   '.join(linaux2) + '\n'
                                        linaux3 = '   ' + '   '.join(linaux3) + '\n'

                                        lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                                        lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                                        lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                                else:
                                    if core_map[auxfarow + 1][auxfacol] != 0:
                                        # 10
                                        contgap += 1

                                        linaux = lines[
                                            findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                                        linaux2 = lines[
                                            findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                                        linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                                        linaux[0] = str(contgap)
                                        linaux[1] = str(contchan)
                                        linaux[2] = str(new_chn_guide[i + 1][j])
                                        linaux[3] = format_e(new_sizes[colinfa])
                                        linaux[4] = format_e(new_sizes[0])

                                        linaux2[0] = str(dlev)

                                        linaux3[1] = format_e(new_coordsX[colinfa] + core_centX[auxfacol])
                                        linaux3[2] = format_e(
                                            new_coordsY[rowinfa] + core_centY[auxfarow] - new_sizes[rowinfa] / 2)
                                        linaux3[3] = 'y'

                                        linaux = '   ' + '   '.join(linaux) + '\n'
                                        linaux2 = '   ' + '   '.join(linaux2) + '\n'
                                        linaux3 = '   ' + '   '.join(linaux3) + '\n'

                                        lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                                        lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                                        lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                            else:
                                if core_map[auxfarow + 1][auxfacol] != 0:
                                    # 11
                                    contgap += 1

                                    linaux = lines[
                                        findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                                    linaux2 = lines[
                                        findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                                    linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                                    linaux[0] = str(contgap)
                                    linaux[1] = str(contchan)
                                    linaux[2] = str(new_chn_guide[i + 1][j])
                                    linaux[3] = format_e(new_sizes[colinfa])
                                    linaux[4] = format_e(new_sizes[0])

                                    linaux2[0] = str(dlev)

                                    linaux3[1] = format_e(new_coordsX[colinfa] + core_centX[auxfacol])
                                    linaux3[2] = format_e(
                                        new_coordsY[rowinfa] + core_centY[auxfarow] - new_sizes[rowinfa] / 2)
                                    linaux3[3] = 'y'

                                    linaux = '   ' + '   '.join(linaux) + '\n'
                                    linaux2 = '   ' + '   '.join(linaux2) + '\n'
                                    linaux3 = '   ' + '   '.join(linaux3) + '\n'

                                    lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                                    lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                                    lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

                        else:
                            if auxfacol != fa_numcol - 1:
                                if core_map[auxfarow][auxfacol + 1] != 0:
                                    contgap += 1
                                    linaux = lines[
                                        findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)].split()
                                    linaux2 = lines[
                                        findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)].split()
                                    linaux3 = lines[findheaderinline(lines, "K X  Y  NORM ") + contgap].split()

                                    linaux[0] = str(contgap)
                                    linaux[1] = str(contchan)
                                    linaux[2] = str(new_chn_guide[i][j + 1])
                                    linaux[3] = format_e(new_sizes[rowinfa])
                                    linaux[4] = format_e(new_sizes[0])

                                    linaux2[0] = str(dlev)

                                    linaux3[1] = format_e(
                                        new_coordsX[colinfa] + core_centX[auxfacol] + new_sizes[colinfa] / 2)
                                    linaux3[2] = format_e(new_coordsY[rowinfa] + core_centY[auxfarow])
                                    linaux3[3] = 'x'

                                    linaux = '   ' + '   '.join(linaux) + '\n'
                                    linaux2 = '   ' + '   '.join(linaux2) + '\n'
                                    linaux3 = '   ' + '   '.join(linaux3) + '\n'

                                    lines[findheaderinline(lines, "K IK  JK") + 3 + 2 * (contgap - 1)] = linaux
                                    lines[findheaderinline(lines, "K IK  JK") + 4 + 2 * (contgap - 1)] = linaux2
                                    lines[findheaderinline(lines, "K X  Y  NORM ") + contgap] = linaux3

    # TODO the process of making the gaps may be simplified with a switch - case structure

    # Deletes Card 9.6 and 9.7

    if not np.all(ngt == 0):
        start = findheaderinline(lines, "Card 9.6")-1
        n_oldlines = findnextto(lines, "Card 9.6", "********") - start - 1
        removeexcesslines(lines, start, n_oldlines, 0)

    # Changes NMAT in Card 10.1

    if ngt > 0:
        substitute(lines, "NMAT NDM2", [1], [0], time=1, fwd=1)

    # Changes NAXP in Card 11.1
    substitute(lines, "NQA NAXP MNXN", [1], [1], time=1, fwd=1)

    # Deletes second axial profile (repeated Cards 11.3 and 11.4, that is included when there exist guide tubes.
    # In future versions this could be linked to the number of axial profiles left.

    if ngt[0] > 0:
        deletebetweencards(lines, "Card 11.3", "Card 11.7", 2)

    # Changes number of boundary conditions in Card 13.1

    substitute(lines, "NBND NKBD NFUN", [2*newchn_tot], [0], time=1, fwd=1)

    # deletes excess of boundary conditions in card 13.4

    removeexcesslines(lines, findheaderinline(lines, "IBD1 IBD2", time=1), nchn_tot, newchn_tot)
    removeexcesslines(lines, findheaderinline(lines, "outlet b.c.", time=1), nchn_tot, newchn_tot)

    # Changes names of the .hdf5 and .vtk files in Card 17.1
    
    line_aux = [namehdf5 + '_dlev' + str(dlev) + '.hdf5', namevtk + '_dlev' + str(dlev) + '.vtk']
    line_aux = '     ' + '    '.join(line_aux) + '\n'
    lines[findheaderinline(lines, "HDF5_NAME VTK_NAME") + 1] = line_aux
    
    # Changes the rod map dimensions in Card 17.2
    substitute(lines, "TOTRODSROW TOTRODSCOL", [totrodsrow_n, totrodscol_n], [0, 1], time=1, fwd=1)

    # Changes the channel map dimensions in Card 17.3
    substitute(lines, "TOTCHANSROW TOTCHANSCOL", [totchansrow_n, totchanscol_n], [0, 1], time=1, fwd=1)

    # Deletes previous rod maps and channel maps

    removeexcesslines(lines, findcardinline(lines, "Card 17.4 - Rod Map"), totrodsrow_o, totrodsrow_n)
    removeexcesslines(lines, findcardinline(lines, "Card 17.4 - Channel Map"), totchansrow_o, totchansrow_n)

    for i in range(0, totrodsrow_n):
        line_aux = []
        for j in range(0, totrodscol_n):
            line_aux.append(str(newrodsmap[i][j]))

        line_aux = '     ' + '   '.join(line_aux) + '\n'
        lines[findheaderinline(lines, "Card 17.4 - Rod Map", time=1) + 1+i] = line_aux
        lines[findheaderinline(lines, "Card 17.4 - Channel Map", time=1) + 1 + i] = line_aux

    # ---------------------------------------END OF MAIN--------------------------------------------------

    file = open('new_deck.inp', 'w')
    file.writelines(lines)
    file.close()

    filename = "Channelsmap.txt"
    file_path = os.path.abspath(__file__)
    file_exists = os.path.isfile(filename)

    if file_exists:

        full_path = os.path.join(file_path, filename)
        os.remove(full_path)

    else:
        file = open(filename, 'w')
        file.close()

    file = open(filename, 'r')
    chanmaplines = file.readlines()
    file.close()

    chanmaplines.append("Dlev |  Nº of old channels | Nº of new channels | Nº of units \n")
    chanmaplines.append(" " + str(dlev) + "       " + str(oldnchn) + "      " + str(newchn_tot) +
                        "      " + str(n_units) + "\n")
    chanmaplines.append("Nº of lines to read \n")
    chanmaplines.append(" " + str(tot_teor_chn) + "\n\n")

    aux = int(0)
    for i in range(0, totchansrow_s):
        for j in range(0, totchanscol_s):
            if totsubchn_in_chn[i][j][0] != 0:
                aux += 1
                chanmaplines.append(str(aux) + "  " + str(totsubchn_in_chn[i][j][0]) + "  " +
                                    str(totsubchn_in_chn[i][j][1]) + "\n")

    chanmaplines.append('\n Comparison units for the homogenized channels \n')
    chanmaplines.append('------------------------------------------------- \n')
    aux = 0
    for i in range(0, totchansrow_n):
        for j in range(0, totrodscol_n):
            if units_guide[i][j] != 0:
                aux += 1
                chanmaplines.append(str(aux) + "     " + str(units_guide[i][j]) + "\n")
    file = open(filename, 'w')
    file.writelines(chanmaplines)
    file.close()

    # TODO Assess that it is compatible with different assembly types and power profiles
    # TODO correct the alignment when writing lines (e.g. in channels or gaps cards) -> deck.inp file is more readable
    # TODO merge the procedure of obtaining a variable from a document (line_aux etc) in a function


main()


